// Generated by jextract

package com.davidvlijmincx.lio.generated.io.uring;

import java.lang.foreign.*;
import java.lang.invoke.VarHandle;
import java.util.function.Consumer;

import static java.lang.foreign.MemoryLayout.PathElement.groupElement;
import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;
import static java.lang.foreign.ValueLayout.*;

/**
 * {@snippet lang=c :
 * struct {
 *     int si_signo;
 *     int si_errno;
 *     int si_code;
 *     int __pad0;
 *     union {
 *         int _pad[28];
 *         struct {
 *             __pid_t si_pid;
 *             __uid_t si_uid;
 *         } _kill;
 *         struct {
 *             int si_tid;
 *             int si_overrun;
 *             __sigval_t si_sigval;
 *         } _timer;
 *         struct {
 *             __pid_t si_pid;
 *             __uid_t si_uid;
 *             __sigval_t si_sigval;
 *         } _rt;
 *         struct {
 *             __pid_t si_pid;
 *             __uid_t si_uid;
 *             int si_status;
 *             __clock_t si_utime;
 *             __clock_t si_stime;
 *         } _sigchld;
 *         struct {
 *             void *si_addr;
 *             short si_addr_lsb;
 *             union {
 *                 struct {
 *                     void *_lower;
 *                     void *_upper;
 *                 } _addr_bnd;
 *                 __uint32_t _pkey;
 *             } _bounds;
 *         } _sigfault;
 *         struct {
 *             long si_band;
 *             int si_fd;
 *         } _sigpoll;
 *         struct {
 *             void *_call_addr;
 *             int _syscall;
 *             unsigned int _arch;
 *         } _sigsys;
 *     } _sifields;
 * }
 * }
 */
public class siginfo_t {

    siginfo_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        liburingtest.C_INT.withName("si_signo"),
        liburingtest.C_INT.withName("si_errno"),
        liburingtest.C_INT.withName("si_code"),
        liburingtest.C_INT.withName("__pad0"),
        _sifields.layout().withName("_sifields")
    ).withName("$anon$36:9");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt si_signo$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_signo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int si_signo
     * }
     */
    public static final OfInt si_signo$layout() {
        return si_signo$LAYOUT;
    }

    private static final long si_signo$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int si_signo
     * }
     */
    public static final long si_signo$offset() {
        return si_signo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int si_signo
     * }
     */
    public static int si_signo(MemorySegment struct) {
        return struct.get(si_signo$LAYOUT, si_signo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int si_signo
     * }
     */
    public static void si_signo(MemorySegment struct, int fieldValue) {
        struct.set(si_signo$LAYOUT, si_signo$OFFSET, fieldValue);
    }

    private static final OfInt si_errno$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_errno"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int si_errno
     * }
     */
    public static final OfInt si_errno$layout() {
        return si_errno$LAYOUT;
    }

    private static final long si_errno$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int si_errno
     * }
     */
    public static final long si_errno$offset() {
        return si_errno$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int si_errno
     * }
     */
    public static int si_errno(MemorySegment struct) {
        return struct.get(si_errno$LAYOUT, si_errno$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int si_errno
     * }
     */
    public static void si_errno(MemorySegment struct, int fieldValue) {
        struct.set(si_errno$LAYOUT, si_errno$OFFSET, fieldValue);
    }

    private static final OfInt si_code$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_code"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int si_code
     * }
     */
    public static final OfInt si_code$layout() {
        return si_code$LAYOUT;
    }

    private static final long si_code$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int si_code
     * }
     */
    public static final long si_code$offset() {
        return si_code$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int si_code
     * }
     */
    public static int si_code(MemorySegment struct) {
        return struct.get(si_code$LAYOUT, si_code$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int si_code
     * }
     */
    public static void si_code(MemorySegment struct, int fieldValue) {
        struct.set(si_code$LAYOUT, si_code$OFFSET, fieldValue);
    }

    private static final OfInt __pad0$LAYOUT = (OfInt)$LAYOUT.select(groupElement("__pad0"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int __pad0
     * }
     */
    public static final OfInt __pad0$layout() {
        return __pad0$LAYOUT;
    }

    private static final long __pad0$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int __pad0
     * }
     */
    public static final long __pad0$offset() {
        return __pad0$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int __pad0
     * }
     */
    public static int __pad0(MemorySegment struct) {
        return struct.get(__pad0$LAYOUT, __pad0$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int __pad0
     * }
     */
    public static void __pad0(MemorySegment struct, int fieldValue) {
        struct.set(__pad0$LAYOUT, __pad0$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union {
     *     int _pad[28];
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *     } _kill;
     *     struct {
     *         int si_tid;
     *         int si_overrun;
     *         __sigval_t si_sigval;
     *     } _timer;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         __sigval_t si_sigval;
     *     } _rt;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         int si_status;
     *         __clock_t si_utime;
     *         __clock_t si_stime;
     *     } _sigchld;
     *     struct {
     *         void *si_addr;
     *         short si_addr_lsb;
     *         union {
     *             struct {
     *                 void *_lower;
     *                 void *_upper;
     *             } _addr_bnd;
     *             __uint32_t _pkey;
     *         } _bounds;
     *     } _sigfault;
     *     struct {
     *         long si_band;
     *         int si_fd;
     *     } _sigpoll;
     *     struct {
     *         void *_call_addr;
     *         int _syscall;
     *         unsigned int _arch;
     *     } _sigsys;
     * }
     * }
     */
    public static class _sifields {

        _sifields() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            MemoryLayout.sequenceLayout(28, liburingtest.C_INT).withName("_pad"),
            _kill.layout().withName("_kill"),
            _timer.layout().withName("_timer"),
            _rt.layout().withName("_rt"),
            _sigchld.layout().withName("_sigchld"),
            _sigfault.layout().withName("_sigfault"),
            _sigpoll.layout().withName("_sigpoll"),
            _sigsys.layout().withName("_sigsys")
        ).withName("$anon$51:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final SequenceLayout _pad$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("_pad"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static final SequenceLayout _pad$layout() {
            return _pad$LAYOUT;
        }

        private static final long _pad$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static final long _pad$offset() {
            return _pad$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static MemorySegment _pad(MemorySegment union) {
            return union.asSlice(_pad$OFFSET, _pad$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static void _pad(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _pad$OFFSET, _pad$LAYOUT.byteSize());
        }

        private static long[] _pad$DIMS = { 28 };

        /**
         * Dimensions for array field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static long[] _pad$dimensions() {
            return _pad$DIMS;
        }
        private static final VarHandle _pad$ELEM_HANDLE = _pad$LAYOUT.varHandle(sequenceElement());

        /**
         * Indexed getter for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static int _pad(MemorySegment union, long index0) {
            return (int)_pad$ELEM_HANDLE.get(union, 0L, index0);
        }

        /**
         * Indexed setter for field:
         * {@snippet lang=c :
         * int _pad[28]
         * }
         */
        public static void _pad(MemorySegment union, long index0, int fieldValue) {
            _pad$ELEM_HANDLE.set(union, 0L, index0, fieldValue);
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         * }
         * }
         */
        public static class _kill {

            _kill() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_INT.withName("si_pid"),
                liburingtest.C_INT.withName("si_uid")
            ).withName("$anon$56:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt si_pid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_pid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final OfInt si_pid$layout() {
                return si_pid$LAYOUT;
            }

            private static final long si_pid$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final long si_pid$offset() {
                return si_pid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static int si_pid(MemorySegment struct) {
                return struct.get(si_pid$LAYOUT, si_pid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static void si_pid(MemorySegment struct, int fieldValue) {
                struct.set(si_pid$LAYOUT, si_pid$OFFSET, fieldValue);
            }

            private static final OfInt si_uid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_uid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final OfInt si_uid$layout() {
                return si_uid$LAYOUT;
            }

            private static final long si_uid$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final long si_uid$offset() {
                return si_uid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static int si_uid(MemorySegment struct) {
                return struct.get(si_uid$LAYOUT, si_uid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static void si_uid(MemorySegment struct, int fieldValue) {
                struct.set(si_uid$LAYOUT, si_uid$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _kill$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_kill"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         * } _kill
         * }
         */
        public static final GroupLayout _kill$layout() {
            return _kill$LAYOUT;
        }

        private static final long _kill$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         * } _kill
         * }
         */
        public static final long _kill$offset() {
            return _kill$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         * } _kill
         * }
         */
        public static MemorySegment _kill(MemorySegment union) {
            return union.asSlice(_kill$OFFSET, _kill$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         * } _kill
         * }
         */
        public static void _kill(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _kill$OFFSET, _kill$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     int si_tid;
         *     int si_overrun;
         *     __sigval_t si_sigval;
         * }
         * }
         */
        public static class _timer {

            _timer() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_INT.withName("si_tid"),
                liburingtest.C_INT.withName("si_overrun"),
                sigval.layout().withName("si_sigval")
            ).withName("$anon$63:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt si_tid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_tid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * int si_tid
             * }
             */
            public static final OfInt si_tid$layout() {
                return si_tid$LAYOUT;
            }

            private static final long si_tid$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * int si_tid
             * }
             */
            public static final long si_tid$offset() {
                return si_tid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * int si_tid
             * }
             */
            public static int si_tid(MemorySegment struct) {
                return struct.get(si_tid$LAYOUT, si_tid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * int si_tid
             * }
             */
            public static void si_tid(MemorySegment struct, int fieldValue) {
                struct.set(si_tid$LAYOUT, si_tid$OFFSET, fieldValue);
            }

            private static final OfInt si_overrun$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_overrun"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * int si_overrun
             * }
             */
            public static final OfInt si_overrun$layout() {
                return si_overrun$LAYOUT;
            }

            private static final long si_overrun$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * int si_overrun
             * }
             */
            public static final long si_overrun$offset() {
                return si_overrun$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * int si_overrun
             * }
             */
            public static int si_overrun(MemorySegment struct) {
                return struct.get(si_overrun$LAYOUT, si_overrun$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * int si_overrun
             * }
             */
            public static void si_overrun(MemorySegment struct, int fieldValue) {
                struct.set(si_overrun$LAYOUT, si_overrun$OFFSET, fieldValue);
            }

            private static final GroupLayout si_sigval$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("si_sigval"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static final GroupLayout si_sigval$layout() {
                return si_sigval$LAYOUT;
            }

            private static final long si_sigval$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static final long si_sigval$offset() {
                return si_sigval$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static MemorySegment si_sigval(MemorySegment struct) {
                return struct.asSlice(si_sigval$OFFSET, si_sigval$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static void si_sigval(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, si_sigval$OFFSET, si_sigval$LAYOUT.byteSize());
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _timer$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_timer"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     int si_tid;
         *     int si_overrun;
         *     __sigval_t si_sigval;
         * } _timer
         * }
         */
        public static final GroupLayout _timer$layout() {
            return _timer$LAYOUT;
        }

        private static final long _timer$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     int si_tid;
         *     int si_overrun;
         *     __sigval_t si_sigval;
         * } _timer
         * }
         */
        public static final long _timer$offset() {
            return _timer$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     int si_tid;
         *     int si_overrun;
         *     __sigval_t si_sigval;
         * } _timer
         * }
         */
        public static MemorySegment _timer(MemorySegment union) {
            return union.asSlice(_timer$OFFSET, _timer$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     int si_tid;
         *     int si_overrun;
         *     __sigval_t si_sigval;
         * } _timer
         * }
         */
        public static void _timer(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _timer$OFFSET, _timer$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     __sigval_t si_sigval;
         * }
         * }
         */
        public static class _rt {

            _rt() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_INT.withName("si_pid"),
                liburingtest.C_INT.withName("si_uid"),
                sigval.layout().withName("si_sigval")
            ).withName("$anon$71:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt si_pid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_pid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final OfInt si_pid$layout() {
                return si_pid$LAYOUT;
            }

            private static final long si_pid$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final long si_pid$offset() {
                return si_pid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static int si_pid(MemorySegment struct) {
                return struct.get(si_pid$LAYOUT, si_pid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static void si_pid(MemorySegment struct, int fieldValue) {
                struct.set(si_pid$LAYOUT, si_pid$OFFSET, fieldValue);
            }

            private static final OfInt si_uid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_uid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final OfInt si_uid$layout() {
                return si_uid$LAYOUT;
            }

            private static final long si_uid$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final long si_uid$offset() {
                return si_uid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static int si_uid(MemorySegment struct) {
                return struct.get(si_uid$LAYOUT, si_uid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static void si_uid(MemorySegment struct, int fieldValue) {
                struct.set(si_uid$LAYOUT, si_uid$OFFSET, fieldValue);
            }

            private static final GroupLayout si_sigval$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("si_sigval"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static final GroupLayout si_sigval$layout() {
                return si_sigval$LAYOUT;
            }

            private static final long si_sigval$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static final long si_sigval$offset() {
                return si_sigval$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static MemorySegment si_sigval(MemorySegment struct) {
                return struct.asSlice(si_sigval$OFFSET, si_sigval$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __sigval_t si_sigval
             * }
             */
            public static void si_sigval(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, si_sigval$OFFSET, si_sigval$LAYOUT.byteSize());
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _rt$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_rt"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     __sigval_t si_sigval;
         * } _rt
         * }
         */
        public static final GroupLayout _rt$layout() {
            return _rt$LAYOUT;
        }

        private static final long _rt$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     __sigval_t si_sigval;
         * } _rt
         * }
         */
        public static final long _rt$offset() {
            return _rt$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     __sigval_t si_sigval;
         * } _rt
         * }
         */
        public static MemorySegment _rt(MemorySegment union) {
            return union.asSlice(_rt$OFFSET, _rt$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     __sigval_t si_sigval;
         * } _rt
         * }
         */
        public static void _rt(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _rt$OFFSET, _rt$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     int si_status;
         *     __clock_t si_utime;
         *     __clock_t si_stime;
         * }
         * }
         */
        public static class _sigchld {

            _sigchld() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_INT.withName("si_pid"),
                liburingtest.C_INT.withName("si_uid"),
                liburingtest.C_INT.withName("si_status"),
                MemoryLayout.paddingLayout(4),
                liburingtest.C_LONG.withName("si_utime"),
                liburingtest.C_LONG.withName("si_stime")
            ).withName("$anon$79:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfInt si_pid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_pid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final OfInt si_pid$layout() {
                return si_pid$LAYOUT;
            }

            private static final long si_pid$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static final long si_pid$offset() {
                return si_pid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static int si_pid(MemorySegment struct) {
                return struct.get(si_pid$LAYOUT, si_pid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __pid_t si_pid
             * }
             */
            public static void si_pid(MemorySegment struct, int fieldValue) {
                struct.set(si_pid$LAYOUT, si_pid$OFFSET, fieldValue);
            }

            private static final OfInt si_uid$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_uid"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final OfInt si_uid$layout() {
                return si_uid$LAYOUT;
            }

            private static final long si_uid$OFFSET = 4;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static final long si_uid$offset() {
                return si_uid$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static int si_uid(MemorySegment struct) {
                return struct.get(si_uid$LAYOUT, si_uid$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __uid_t si_uid
             * }
             */
            public static void si_uid(MemorySegment struct, int fieldValue) {
                struct.set(si_uid$LAYOUT, si_uid$OFFSET, fieldValue);
            }

            private static final OfInt si_status$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_status"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * int si_status
             * }
             */
            public static final OfInt si_status$layout() {
                return si_status$LAYOUT;
            }

            private static final long si_status$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * int si_status
             * }
             */
            public static final long si_status$offset() {
                return si_status$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * int si_status
             * }
             */
            public static int si_status(MemorySegment struct) {
                return struct.get(si_status$LAYOUT, si_status$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * int si_status
             * }
             */
            public static void si_status(MemorySegment struct, int fieldValue) {
                struct.set(si_status$LAYOUT, si_status$OFFSET, fieldValue);
            }

            private static final OfLong si_utime$LAYOUT = (OfLong)$LAYOUT.select(groupElement("si_utime"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __clock_t si_utime
             * }
             */
            public static final OfLong si_utime$layout() {
                return si_utime$LAYOUT;
            }

            private static final long si_utime$OFFSET = 16;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __clock_t si_utime
             * }
             */
            public static final long si_utime$offset() {
                return si_utime$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __clock_t si_utime
             * }
             */
            public static long si_utime(MemorySegment struct) {
                return struct.get(si_utime$LAYOUT, si_utime$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __clock_t si_utime
             * }
             */
            public static void si_utime(MemorySegment struct, long fieldValue) {
                struct.set(si_utime$LAYOUT, si_utime$OFFSET, fieldValue);
            }

            private static final OfLong si_stime$LAYOUT = (OfLong)$LAYOUT.select(groupElement("si_stime"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * __clock_t si_stime
             * }
             */
            public static final OfLong si_stime$layout() {
                return si_stime$LAYOUT;
            }

            private static final long si_stime$OFFSET = 24;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * __clock_t si_stime
             * }
             */
            public static final long si_stime$offset() {
                return si_stime$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * __clock_t si_stime
             * }
             */
            public static long si_stime(MemorySegment struct) {
                return struct.get(si_stime$LAYOUT, si_stime$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * __clock_t si_stime
             * }
             */
            public static void si_stime(MemorySegment struct, long fieldValue) {
                struct.set(si_stime$LAYOUT, si_stime$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _sigchld$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_sigchld"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     int si_status;
         *     __clock_t si_utime;
         *     __clock_t si_stime;
         * } _sigchld
         * }
         */
        public static final GroupLayout _sigchld$layout() {
            return _sigchld$LAYOUT;
        }

        private static final long _sigchld$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     int si_status;
         *     __clock_t si_utime;
         *     __clock_t si_stime;
         * } _sigchld
         * }
         */
        public static final long _sigchld$offset() {
            return _sigchld$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     int si_status;
         *     __clock_t si_utime;
         *     __clock_t si_stime;
         * } _sigchld
         * }
         */
        public static MemorySegment _sigchld(MemorySegment union) {
            return union.asSlice(_sigchld$OFFSET, _sigchld$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     __pid_t si_pid;
         *     __uid_t si_uid;
         *     int si_status;
         *     __clock_t si_utime;
         *     __clock_t si_stime;
         * } _sigchld
         * }
         */
        public static void _sigchld(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _sigchld$OFFSET, _sigchld$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     void *si_addr;
         *     short si_addr_lsb;
         *     union {
         *         struct {
         *             void *_lower;
         *             void *_upper;
         *         } _addr_bnd;
         *         __uint32_t _pkey;
         *     } _bounds;
         * }
         * }
         */
        public static class _sigfault {

            _sigfault() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_POINTER.withName("si_addr"),
                liburingtest.C_SHORT.withName("si_addr_lsb"),
                MemoryLayout.paddingLayout(6),
                _bounds.layout().withName("_bounds")
            ).withName("$anon$89:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final AddressLayout si_addr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("si_addr"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * void *si_addr
             * }
             */
            public static final AddressLayout si_addr$layout() {
                return si_addr$LAYOUT;
            }

            private static final long si_addr$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * void *si_addr
             * }
             */
            public static final long si_addr$offset() {
                return si_addr$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * void *si_addr
             * }
             */
            public static MemorySegment si_addr(MemorySegment struct) {
                return struct.get(si_addr$LAYOUT, si_addr$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * void *si_addr
             * }
             */
            public static void si_addr(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(si_addr$LAYOUT, si_addr$OFFSET, fieldValue);
            }

            private static final OfShort si_addr_lsb$LAYOUT = (OfShort)$LAYOUT.select(groupElement("si_addr_lsb"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * short si_addr_lsb
             * }
             */
            public static final OfShort si_addr_lsb$layout() {
                return si_addr_lsb$LAYOUT;
            }

            private static final long si_addr_lsb$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * short si_addr_lsb
             * }
             */
            public static final long si_addr_lsb$offset() {
                return si_addr_lsb$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * short si_addr_lsb
             * }
             */
            public static short si_addr_lsb(MemorySegment struct) {
                return struct.get(si_addr_lsb$LAYOUT, si_addr_lsb$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * short si_addr_lsb
             * }
             */
            public static void si_addr_lsb(MemorySegment struct, short fieldValue) {
                struct.set(si_addr_lsb$LAYOUT, si_addr_lsb$OFFSET, fieldValue);
            }

            /**
             * {@snippet lang=c :
             * union {
             *     struct {
             *         void *_lower;
             *         void *_upper;
             *     } _addr_bnd;
             *     __uint32_t _pkey;
             * }
             * }
             */
            public static class _bounds {

                _bounds() {
                    // Should not be called directly
                }

                private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
                    _addr_bnd.layout().withName("_addr_bnd"),
                    liburingtest.C_INT.withName("_pkey")
                ).withName("$anon$94:6");

                /**
                 * The layout of this union
                 */
                public static final GroupLayout layout() {
                    return $LAYOUT;
                }

                /**
                 * {@snippet lang=c :
                 * struct {
                 *     void *_lower;
                 *     void *_upper;
                 * }
                 * }
                 */
                public static class _addr_bnd {

                    _addr_bnd() {
                        // Should not be called directly
                    }

                    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                        liburingtest.C_POINTER.withName("_lower"),
                        liburingtest.C_POINTER.withName("_upper")
                    ).withName("$anon$97:3");

                    /**
                     * The layout of this struct
                     */
                    public static final GroupLayout layout() {
                        return $LAYOUT;
                    }

                    private static final AddressLayout _lower$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_lower"));

                    /**
                     * Layout for field:
                     * {@snippet lang=c :
                     * void *_lower
                     * }
                     */
                    public static final AddressLayout _lower$layout() {
                        return _lower$LAYOUT;
                    }

                    private static final long _lower$OFFSET = 0;

                    /**
                     * Offset for field:
                     * {@snippet lang=c :
                     * void *_lower
                     * }
                     */
                    public static final long _lower$offset() {
                        return _lower$OFFSET;
                    }

                    /**
                     * Getter for field:
                     * {@snippet lang=c :
                     * void *_lower
                     * }
                     */
                    public static MemorySegment _lower(MemorySegment struct) {
                        return struct.get(_lower$LAYOUT, _lower$OFFSET);
                    }

                    /**
                     * Setter for field:
                     * {@snippet lang=c :
                     * void *_lower
                     * }
                     */
                    public static void _lower(MemorySegment struct, MemorySegment fieldValue) {
                        struct.set(_lower$LAYOUT, _lower$OFFSET, fieldValue);
                    }

                    private static final AddressLayout _upper$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_upper"));

                    /**
                     * Layout for field:
                     * {@snippet lang=c :
                     * void *_upper
                     * }
                     */
                    public static final AddressLayout _upper$layout() {
                        return _upper$LAYOUT;
                    }

                    private static final long _upper$OFFSET = 8;

                    /**
                     * Offset for field:
                     * {@snippet lang=c :
                     * void *_upper
                     * }
                     */
                    public static final long _upper$offset() {
                        return _upper$OFFSET;
                    }

                    /**
                     * Getter for field:
                     * {@snippet lang=c :
                     * void *_upper
                     * }
                     */
                    public static MemorySegment _upper(MemorySegment struct) {
                        return struct.get(_upper$LAYOUT, _upper$OFFSET);
                    }

                    /**
                     * Setter for field:
                     * {@snippet lang=c :
                     * void *_upper
                     * }
                     */
                    public static void _upper(MemorySegment struct, MemorySegment fieldValue) {
                        struct.set(_upper$LAYOUT, _upper$OFFSET, fieldValue);
                    }

                    /**
                     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                     */
                    public static MemorySegment asSlice(MemorySegment array, long index) {
                        return array.asSlice(layout().byteSize() * index);
                    }

                    /**
                     * The size (in bytes) of this struct
                     */
                    public static long sizeof() { return layout().byteSize(); }

                    /**
                     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                     */
                    public static MemorySegment allocate(SegmentAllocator allocator) {
                        return allocator.allocate(layout());
                    }

                    /**
                     * Allocate an array of size {@code elementCount} using {@code allocator}.
                     * The returned segment has size {@code elementCount * layout().byteSize()}.
                     */
                    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                    }

                    /**
                     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                     * The returned segment has size {@code layout().byteSize()}
                     */
                    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                        return reinterpret(addr, 1, arena, cleanup);
                    }

                    /**
                     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                     * The returned segment has size {@code elementCount * layout().byteSize()}
                     */
                    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                    }
                }

                private static final GroupLayout _addr_bnd$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_addr_bnd"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * struct {
                 *     void *_lower;
                 *     void *_upper;
                 * } _addr_bnd
                 * }
                 */
                public static final GroupLayout _addr_bnd$layout() {
                    return _addr_bnd$LAYOUT;
                }

                private static final long _addr_bnd$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * struct {
                 *     void *_lower;
                 *     void *_upper;
                 * } _addr_bnd
                 * }
                 */
                public static final long _addr_bnd$offset() {
                    return _addr_bnd$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * struct {
                 *     void *_lower;
                 *     void *_upper;
                 * } _addr_bnd
                 * }
                 */
                public static MemorySegment _addr_bnd(MemorySegment union) {
                    return union.asSlice(_addr_bnd$OFFSET, _addr_bnd$LAYOUT.byteSize());
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * struct {
                 *     void *_lower;
                 *     void *_upper;
                 * } _addr_bnd
                 * }
                 */
                public static void _addr_bnd(MemorySegment union, MemorySegment fieldValue) {
                    MemorySegment.copy(fieldValue, 0L, union, _addr_bnd$OFFSET, _addr_bnd$LAYOUT.byteSize());
                }

                private static final OfInt _pkey$LAYOUT = (OfInt)$LAYOUT.select(groupElement("_pkey"));

                /**
                 * Layout for field:
                 * {@snippet lang=c :
                 * __uint32_t _pkey
                 * }
                 */
                public static final OfInt _pkey$layout() {
                    return _pkey$LAYOUT;
                }

                private static final long _pkey$OFFSET = 0;

                /**
                 * Offset for field:
                 * {@snippet lang=c :
                 * __uint32_t _pkey
                 * }
                 */
                public static final long _pkey$offset() {
                    return _pkey$OFFSET;
                }

                /**
                 * Getter for field:
                 * {@snippet lang=c :
                 * __uint32_t _pkey
                 * }
                 */
                public static int _pkey(MemorySegment union) {
                    return union.get(_pkey$LAYOUT, _pkey$OFFSET);
                }

                /**
                 * Setter for field:
                 * {@snippet lang=c :
                 * __uint32_t _pkey
                 * }
                 */
                public static void _pkey(MemorySegment union, int fieldValue) {
                    union.set(_pkey$LAYOUT, _pkey$OFFSET, fieldValue);
                }

                /**
                 * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
                 * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
                 */
                public static MemorySegment asSlice(MemorySegment array, long index) {
                    return array.asSlice(layout().byteSize() * index);
                }

                /**
                 * The size (in bytes) of this union
                 */
                public static long sizeof() { return layout().byteSize(); }

                /**
                 * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
                 */
                public static MemorySegment allocate(SegmentAllocator allocator) {
                    return allocator.allocate(layout());
                }

                /**
                 * Allocate an array of size {@code elementCount} using {@code allocator}.
                 * The returned segment has size {@code elementCount * layout().byteSize()}.
                 */
                public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                    return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                    return reinterpret(addr, 1, arena, cleanup);
                }

                /**
                 * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
                 * The returned segment has size {@code elementCount * layout().byteSize()}
                 */
                public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                    return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
                }
            }

            private static final GroupLayout _bounds$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_bounds"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         void *_lower;
             *         void *_upper;
             *     } _addr_bnd;
             *     __uint32_t _pkey;
             * } _bounds
             * }
             */
            public static final GroupLayout _bounds$layout() {
                return _bounds$LAYOUT;
            }

            private static final long _bounds$OFFSET = 16;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         void *_lower;
             *         void *_upper;
             *     } _addr_bnd;
             *     __uint32_t _pkey;
             * } _bounds
             * }
             */
            public static final long _bounds$offset() {
                return _bounds$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         void *_lower;
             *         void *_upper;
             *     } _addr_bnd;
             *     __uint32_t _pkey;
             * } _bounds
             * }
             */
            public static MemorySegment _bounds(MemorySegment struct) {
                return struct.asSlice(_bounds$OFFSET, _bounds$LAYOUT.byteSize());
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * union {
             *     struct {
             *         void *_lower;
             *         void *_upper;
             *     } _addr_bnd;
             *     __uint32_t _pkey;
             * } _bounds
             * }
             */
            public static void _bounds(MemorySegment struct, MemorySegment fieldValue) {
                MemorySegment.copy(fieldValue, 0L, struct, _bounds$OFFSET, _bounds$LAYOUT.byteSize());
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _sigfault$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_sigfault"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     void *si_addr;
         *     short si_addr_lsb;
         *     union {
         *         struct {
         *             void *_lower;
         *             void *_upper;
         *         } _addr_bnd;
         *         __uint32_t _pkey;
         *     } _bounds;
         * } _sigfault
         * }
         */
        public static final GroupLayout _sigfault$layout() {
            return _sigfault$LAYOUT;
        }

        private static final long _sigfault$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     void *si_addr;
         *     short si_addr_lsb;
         *     union {
         *         struct {
         *             void *_lower;
         *             void *_upper;
         *         } _addr_bnd;
         *         __uint32_t _pkey;
         *     } _bounds;
         * } _sigfault
         * }
         */
        public static final long _sigfault$offset() {
            return _sigfault$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     void *si_addr;
         *     short si_addr_lsb;
         *     union {
         *         struct {
         *             void *_lower;
         *             void *_upper;
         *         } _addr_bnd;
         *         __uint32_t _pkey;
         *     } _bounds;
         * } _sigfault
         * }
         */
        public static MemorySegment _sigfault(MemorySegment union) {
            return union.asSlice(_sigfault$OFFSET, _sigfault$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     void *si_addr;
         *     short si_addr_lsb;
         *     union {
         *         struct {
         *             void *_lower;
         *             void *_upper;
         *         } _addr_bnd;
         *         __uint32_t _pkey;
         *     } _bounds;
         * } _sigfault
         * }
         */
        public static void _sigfault(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _sigfault$OFFSET, _sigfault$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     long si_band;
         *     int si_fd;
         * }
         * }
         */
        public static class _sigpoll {

            _sigpoll() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_LONG.withName("si_band"),
                liburingtest.C_INT.withName("si_fd"),
                MemoryLayout.paddingLayout(4)
            ).withName("$anon$108:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final OfLong si_band$LAYOUT = (OfLong)$LAYOUT.select(groupElement("si_band"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * long si_band
             * }
             */
            public static final OfLong si_band$layout() {
                return si_band$LAYOUT;
            }

            private static final long si_band$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * long si_band
             * }
             */
            public static final long si_band$offset() {
                return si_band$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * long si_band
             * }
             */
            public static long si_band(MemorySegment struct) {
                return struct.get(si_band$LAYOUT, si_band$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * long si_band
             * }
             */
            public static void si_band(MemorySegment struct, long fieldValue) {
                struct.set(si_band$LAYOUT, si_band$OFFSET, fieldValue);
            }

            private static final OfInt si_fd$LAYOUT = (OfInt)$LAYOUT.select(groupElement("si_fd"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * int si_fd
             * }
             */
            public static final OfInt si_fd$layout() {
                return si_fd$LAYOUT;
            }

            private static final long si_fd$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * int si_fd
             * }
             */
            public static final long si_fd$offset() {
                return si_fd$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * int si_fd
             * }
             */
            public static int si_fd(MemorySegment struct) {
                return struct.get(si_fd$LAYOUT, si_fd$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * int si_fd
             * }
             */
            public static void si_fd(MemorySegment struct, int fieldValue) {
                struct.set(si_fd$LAYOUT, si_fd$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _sigpoll$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_sigpoll"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     long si_band;
         *     int si_fd;
         * } _sigpoll
         * }
         */
        public static final GroupLayout _sigpoll$layout() {
            return _sigpoll$LAYOUT;
        }

        private static final long _sigpoll$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     long si_band;
         *     int si_fd;
         * } _sigpoll
         * }
         */
        public static final long _sigpoll$offset() {
            return _sigpoll$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     long si_band;
         *     int si_fd;
         * } _sigpoll
         * }
         */
        public static MemorySegment _sigpoll(MemorySegment union) {
            return union.asSlice(_sigpoll$OFFSET, _sigpoll$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     long si_band;
         *     int si_fd;
         * } _sigpoll
         * }
         */
        public static void _sigpoll(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _sigpoll$OFFSET, _sigpoll$LAYOUT.byteSize());
        }

        /**
         * {@snippet lang=c :
         * struct {
         *     void *_call_addr;
         *     int _syscall;
         *     unsigned int _arch;
         * }
         * }
         */
        public static class _sigsys {

            _sigsys() {
                // Should not be called directly
            }

            private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                liburingtest.C_POINTER.withName("_call_addr"),
                liburingtest.C_INT.withName("_syscall"),
                liburingtest.C_INT.withName("_arch")
            ).withName("$anon$116:2");

            /**
             * The layout of this struct
             */
            public static final GroupLayout layout() {
                return $LAYOUT;
            }

            private static final AddressLayout _call_addr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_call_addr"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * void *_call_addr
             * }
             */
            public static final AddressLayout _call_addr$layout() {
                return _call_addr$LAYOUT;
            }

            private static final long _call_addr$OFFSET = 0;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * void *_call_addr
             * }
             */
            public static final long _call_addr$offset() {
                return _call_addr$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * void *_call_addr
             * }
             */
            public static MemorySegment _call_addr(MemorySegment struct) {
                return struct.get(_call_addr$LAYOUT, _call_addr$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * void *_call_addr
             * }
             */
            public static void _call_addr(MemorySegment struct, MemorySegment fieldValue) {
                struct.set(_call_addr$LAYOUT, _call_addr$OFFSET, fieldValue);
            }

            private static final OfInt _syscall$LAYOUT = (OfInt)$LAYOUT.select(groupElement("_syscall"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * int _syscall
             * }
             */
            public static final OfInt _syscall$layout() {
                return _syscall$LAYOUT;
            }

            private static final long _syscall$OFFSET = 8;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * int _syscall
             * }
             */
            public static final long _syscall$offset() {
                return _syscall$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * int _syscall
             * }
             */
            public static int _syscall(MemorySegment struct) {
                return struct.get(_syscall$LAYOUT, _syscall$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * int _syscall
             * }
             */
            public static void _syscall(MemorySegment struct, int fieldValue) {
                struct.set(_syscall$LAYOUT, _syscall$OFFSET, fieldValue);
            }

            private static final OfInt _arch$LAYOUT = (OfInt)$LAYOUT.select(groupElement("_arch"));

            /**
             * Layout for field:
             * {@snippet lang=c :
             * unsigned int _arch
             * }
             */
            public static final OfInt _arch$layout() {
                return _arch$LAYOUT;
            }

            private static final long _arch$OFFSET = 12;

            /**
             * Offset for field:
             * {@snippet lang=c :
             * unsigned int _arch
             * }
             */
            public static final long _arch$offset() {
                return _arch$OFFSET;
            }

            /**
             * Getter for field:
             * {@snippet lang=c :
             * unsigned int _arch
             * }
             */
            public static int _arch(MemorySegment struct) {
                return struct.get(_arch$LAYOUT, _arch$OFFSET);
            }

            /**
             * Setter for field:
             * {@snippet lang=c :
             * unsigned int _arch
             * }
             */
            public static void _arch(MemorySegment struct, int fieldValue) {
                struct.set(_arch$LAYOUT, _arch$OFFSET, fieldValue);
            }

            /**
             * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
             * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
             */
            public static MemorySegment asSlice(MemorySegment array, long index) {
                return array.asSlice(layout().byteSize() * index);
            }

            /**
             * The size (in bytes) of this struct
             */
            public static long sizeof() { return layout().byteSize(); }

            /**
             * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
             */
            public static MemorySegment allocate(SegmentAllocator allocator) {
                return allocator.allocate(layout());
            }

            /**
             * Allocate an array of size {@code elementCount} using {@code allocator}.
             * The returned segment has size {@code elementCount * layout().byteSize()}.
             */
            public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
                return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
                return reinterpret(addr, 1, arena, cleanup);
            }

            /**
             * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
             * The returned segment has size {@code elementCount * layout().byteSize()}
             */
            public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
                return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
            }
        }

        private static final GroupLayout _sigsys$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_sigsys"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct {
         *     void *_call_addr;
         *     int _syscall;
         *     unsigned int _arch;
         * } _sigsys
         * }
         */
        public static final GroupLayout _sigsys$layout() {
            return _sigsys$LAYOUT;
        }

        private static final long _sigsys$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct {
         *     void *_call_addr;
         *     int _syscall;
         *     unsigned int _arch;
         * } _sigsys
         * }
         */
        public static final long _sigsys$offset() {
            return _sigsys$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct {
         *     void *_call_addr;
         *     int _syscall;
         *     unsigned int _arch;
         * } _sigsys
         * }
         */
        public static MemorySegment _sigsys(MemorySegment union) {
            return union.asSlice(_sigsys$OFFSET, _sigsys$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct {
         *     void *_call_addr;
         *     int _syscall;
         *     unsigned int _arch;
         * } _sigsys
         * }
         */
        public static void _sigsys(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, _sigsys$OFFSET, _sigsys$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout _sifields$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_sifields"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     int _pad[28];
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *     } _kill;
     *     struct {
     *         int si_tid;
     *         int si_overrun;
     *         __sigval_t si_sigval;
     *     } _timer;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         __sigval_t si_sigval;
     *     } _rt;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         int si_status;
     *         __clock_t si_utime;
     *         __clock_t si_stime;
     *     } _sigchld;
     *     struct {
     *         void *si_addr;
     *         short si_addr_lsb;
     *         union {
     *             struct {
     *                 void *_lower;
     *                 void *_upper;
     *             } _addr_bnd;
     *             __uint32_t _pkey;
     *         } _bounds;
     *     } _sigfault;
     *     struct {
     *         long si_band;
     *         int si_fd;
     *     } _sigpoll;
     *     struct {
     *         void *_call_addr;
     *         int _syscall;
     *         unsigned int _arch;
     *     } _sigsys;
     * } _sifields
     * }
     */
    public static final GroupLayout _sifields$layout() {
        return _sifields$LAYOUT;
    }

    private static final long _sifields$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     int _pad[28];
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *     } _kill;
     *     struct {
     *         int si_tid;
     *         int si_overrun;
     *         __sigval_t si_sigval;
     *     } _timer;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         __sigval_t si_sigval;
     *     } _rt;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         int si_status;
     *         __clock_t si_utime;
     *         __clock_t si_stime;
     *     } _sigchld;
     *     struct {
     *         void *si_addr;
     *         short si_addr_lsb;
     *         union {
     *             struct {
     *                 void *_lower;
     *                 void *_upper;
     *             } _addr_bnd;
     *             __uint32_t _pkey;
     *         } _bounds;
     *     } _sigfault;
     *     struct {
     *         long si_band;
     *         int si_fd;
     *     } _sigpoll;
     *     struct {
     *         void *_call_addr;
     *         int _syscall;
     *         unsigned int _arch;
     *     } _sigsys;
     * } _sifields
     * }
     */
    public static final long _sifields$offset() {
        return _sifields$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     int _pad[28];
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *     } _kill;
     *     struct {
     *         int si_tid;
     *         int si_overrun;
     *         __sigval_t si_sigval;
     *     } _timer;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         __sigval_t si_sigval;
     *     } _rt;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         int si_status;
     *         __clock_t si_utime;
     *         __clock_t si_stime;
     *     } _sigchld;
     *     struct {
     *         void *si_addr;
     *         short si_addr_lsb;
     *         union {
     *             struct {
     *                 void *_lower;
     *                 void *_upper;
     *             } _addr_bnd;
     *             __uint32_t _pkey;
     *         } _bounds;
     *     } _sigfault;
     *     struct {
     *         long si_band;
     *         int si_fd;
     *     } _sigpoll;
     *     struct {
     *         void *_call_addr;
     *         int _syscall;
     *         unsigned int _arch;
     *     } _sigsys;
     * } _sifields
     * }
     */
    public static MemorySegment _sifields(MemorySegment struct) {
        return struct.asSlice(_sifields$OFFSET, _sifields$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     int _pad[28];
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *     } _kill;
     *     struct {
     *         int si_tid;
     *         int si_overrun;
     *         __sigval_t si_sigval;
     *     } _timer;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         __sigval_t si_sigval;
     *     } _rt;
     *     struct {
     *         __pid_t si_pid;
     *         __uid_t si_uid;
     *         int si_status;
     *         __clock_t si_utime;
     *         __clock_t si_stime;
     *     } _sigchld;
     *     struct {
     *         void *si_addr;
     *         short si_addr_lsb;
     *         union {
     *             struct {
     *                 void *_lower;
     *                 void *_upper;
     *             } _addr_bnd;
     *             __uint32_t _pkey;
     *         } _bounds;
     *     } _sigfault;
     *     struct {
     *         long si_band;
     *         int si_fd;
     *     } _sigpoll;
     *     struct {
     *         void *_call_addr;
     *         int _syscall;
     *         unsigned int _arch;
     *     } _sigsys;
     * } _sifields
     * }
     */
    public static void _sifields(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, _sifields$OFFSET, _sifields$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

