// Generated by jextract

package com.davidvlijmincx.lio.generated.io.uring;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

import static java.lang.foreign.MemoryLayout.PathElement.sequenceElement;
import static java.lang.foreign.ValueLayout.*;

public class liburingtest_1 extends liburingtest_2 {

    liburingtest_1() {
        // Should not be called directly
    }
    private static final int FPE_INTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_INTOVF = 2
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int FPE_FLTDIV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTDIV = 3
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTOVF = 4
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUND = 5
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTRES = 6
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTINV = 7
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTSUB = 8
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_FLTUNK = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_FLTUNK = 14
     * }
     */
    public static int FPE_FLTUNK() {
        return FPE_FLTUNK;
    }
    private static final int FPE_CONDTRAP = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FPE_CONDTRAP = 15
     * }
     */
    public static int FPE_CONDTRAP() {
        return FPE_CONDTRAP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MAPERR = 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCERR = 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int SEGV_BNDERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_BNDERR = 3
     * }
     */
    public static int SEGV_BNDERR() {
        return SEGV_BNDERR;
    }
    private static final int SEGV_PKUERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_PKUERR = 4
     * }
     */
    public static int SEGV_PKUERR() {
        return SEGV_PKUERR;
    }
    private static final int SEGV_ACCADI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ACCADI = 5
     * }
     */
    public static int SEGV_ACCADI() {
        return SEGV_ACCADI;
    }
    private static final int SEGV_ADIDERR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIDERR = 6
     * }
     */
    public static int SEGV_ADIDERR() {
        return SEGV_ADIDERR;
    }
    private static final int SEGV_ADIPERR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_ADIPERR = 7
     * }
     */
    public static int SEGV_ADIPERR() {
        return SEGV_ADIPERR;
    }
    private static final int SEGV_MTEAERR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTEAERR = 8
     * }
     */
    public static int SEGV_MTEAERR() {
        return SEGV_MTEAERR;
    }
    private static final int SEGV_MTESERR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SEGV_MTESERR = 9
     * }
     */
    public static int SEGV_MTESERR() {
        return SEGV_MTESERR;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRALN = 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_ADRERR = 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_OBJERR = 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int BUS_MCEERR_AR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AR = 4
     * }
     */
    public static int BUS_MCEERR_AR() {
        return BUS_MCEERR_AR;
    }
    private static final int BUS_MCEERR_AO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BUS_MCEERR_AO = 5
     * }
     */
    public static int BUS_MCEERR_AO() {
        return BUS_MCEERR_AO;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_EXITED = 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_KILLED = 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_DUMPED = 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_TRAPPED = 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_STOPPED = 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CLD_CONTINUED = 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_IN = 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_OUT = 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_MSG = 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_ERR = 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_PRI = 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POLL_HUP = 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SIGEV_SIGNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_SIGNAL = 0
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_NONE = 1
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_THREAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD = 2
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int SIGEV_THREAD_ID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SIGEV_THREAD_ID = 4
     * }
     */
    public static int SIGEV_THREAD_ID() {
        return SIGEV_THREAD_ID;
    }

    private static class __sysv_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__sysv_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor __sysv_signal$descriptor() {
        return __sysv_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle __sysv_signal$handle() {
        return __sysv_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal$address() {
        return __sysv_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment __sysv_signal(int __sig, MemorySegment __handler) {
        var mh$ = __sysv_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sysv_signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t signal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment signal(int __sig, MemorySegment __handler) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static FunctionDescriptor kill$descriptor() {
        return kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MethodHandle kill$handle() {
        return kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static MemorySegment kill$address() {
        return kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int kill(__pid_t __pid, int __sig)
     * }
     */
    public static int kill(int __pid, int __sig) {
        var mh$ = kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("kill", __pid, __sig);
            }
            return (int)mh$.invokeExact(__pid, __sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class killpg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("killpg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static FunctionDescriptor killpg$descriptor() {
        return killpg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MethodHandle killpg$handle() {
        return killpg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static MemorySegment killpg$address() {
        return killpg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int killpg(__pid_t __pgrp, int __sig)
     * }
     */
    public static int killpg(int __pgrp, int __sig) {
        var mh$ = killpg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("killpg", __pgrp, __sig);
            }
            return (int)mh$.invokeExact(__pgrp, __sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class raise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("raise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static FunctionDescriptor raise$descriptor() {
        return raise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MethodHandle raise$handle() {
        return raise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static MemorySegment raise$address() {
        return raise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int raise(int __sig)
     * }
     */
    public static int raise(int __sig) {
        var mh$ = raise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("raise", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("ssignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static FunctionDescriptor ssignal$descriptor() {
        return ssignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MethodHandle ssignal$handle() {
        return ssignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal$address() {
        return ssignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __sighandler_t ssignal(int __sig, __sighandler_t __handler)
     * }
     */
    public static MemorySegment ssignal(int __sig, MemorySegment __handler) {
        var mh$ = ssignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssignal", __sig, __handler);
            }
            return (MemorySegment)mh$.invokeExact(__sig, __handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("gsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static FunctionDescriptor gsignal$descriptor() {
        return gsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MethodHandle gsignal$handle() {
        return gsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static MemorySegment gsignal$address() {
        return gsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gsignal(int __sig)
     * }
     */
    public static int gsignal(int __sig) {
        var mh$ = gsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gsignal", __sig);
            }
            return (int)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("psignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static FunctionDescriptor psignal$descriptor() {
        return psignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MethodHandle psignal$handle() {
        return psignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static MemorySegment psignal$address() {
        return psignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psignal(int __sig, const char *__s)
     * }
     */
    public static void psignal(int __sig, MemorySegment __s) {
        var mh$ = psignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psignal", __sig, __s);
            }
            mh$.invokeExact(__sig, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psiginfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("psiginfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static FunctionDescriptor psiginfo$descriptor() {
        return psiginfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MethodHandle psiginfo$handle() {
        return psiginfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static MemorySegment psiginfo$address() {
        return psiginfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void psiginfo(const siginfo_t *__pinfo, const char *__s)
     * }
     */
    public static void psiginfo(MemorySegment __pinfo, MemorySegment __s) {
        var mh$ = psiginfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psiginfo", __pinfo, __s);
            }
            mh$.invokeExact(__pinfo, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigblock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigblock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static FunctionDescriptor sigblock$descriptor() {
        return sigblock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MethodHandle sigblock$handle() {
        return sigblock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static MemorySegment sigblock$address() {
        return sigblock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigblock(int __mask)
     * }
     */
    public static int sigblock(int __mask) {
        var mh$ = sigblock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigblock", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigsetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static FunctionDescriptor sigsetmask$descriptor() {
        return sigsetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MethodHandle sigsetmask$handle() {
        return sigsetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static MemorySegment sigsetmask$address() {
        return sigsetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsetmask(int __mask)
     * }
     */
    public static int sigsetmask(int __mask) {
        var mh$ = sigsetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsetmask", __mask);
            }
            return (int)mh$.invokeExact(__mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class siggetmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("siggetmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static FunctionDescriptor siggetmask$descriptor() {
        return siggetmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MethodHandle siggetmask$handle() {
        return siggetmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static MemorySegment siggetmask$address() {
        return siggetmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siggetmask()
     * }
     */
    public static int siggetmask() {
        var mh$ = siggetmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siggetmask");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigemptyset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigemptyset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigemptyset$descriptor() {
        return sigemptyset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigemptyset$handle() {
        return sigemptyset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigemptyset$address() {
        return sigemptyset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigemptyset(sigset_t *__set)
     * }
     */
    public static int sigemptyset(MemorySegment __set) {
        var mh$ = sigemptyset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigemptyset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigfillset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigfillset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigfillset$descriptor() {
        return sigfillset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MethodHandle sigfillset$handle() {
        return sigfillset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static MemorySegment sigfillset$address() {
        return sigfillset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigfillset(sigset_t *__set)
     * }
     */
    public static int sigfillset(MemorySegment __set) {
        var mh$ = sigfillset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigfillset", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaddset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigaddset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigaddset$descriptor() {
        return sigaddset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigaddset$handle() {
        return sigaddset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigaddset$address() {
        return sigaddset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaddset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigaddset(MemorySegment __set, int __signo) {
        var mh$ = sigaddset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaddset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigdelset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigdelset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigdelset$descriptor() {
        return sigdelset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigdelset$handle() {
        return sigdelset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigdelset$address() {
        return sigdelset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigdelset(sigset_t *__set, int __signo)
     * }
     */
    public static int sigdelset(MemorySegment __set, int __signo) {
        var mh$ = sigdelset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigdelset", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigismember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigismember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static FunctionDescriptor sigismember$descriptor() {
        return sigismember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MethodHandle sigismember$handle() {
        return sigismember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static MemorySegment sigismember$address() {
        return sigismember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigismember(const sigset_t *__set, int __signo)
     * }
     */
    public static int sigismember(MemorySegment __set, int __signo) {
        var mh$ = sigismember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigismember", __set, __signo);
            }
            return (int)mh$.invokeExact(__set, __signo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigprocmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigprocmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static FunctionDescriptor sigprocmask$descriptor() {
        return sigprocmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MethodHandle sigprocmask$handle() {
        return sigprocmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static MemorySegment sigprocmask$address() {
        return sigprocmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)
     * }
     */
    public static int sigprocmask(int __how, MemorySegment __set, MemorySegment __oset) {
        var mh$ = sigprocmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigprocmask", __how, __set, __oset);
            }
            return (int)mh$.invokeExact(__how, __set, __oset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigsuspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigsuspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigsuspend$descriptor() {
        return sigsuspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MethodHandle sigsuspend$handle() {
        return sigsuspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static MemorySegment sigsuspend$address() {
        return sigsuspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigsuspend(const sigset_t *__set)
     * }
     */
    public static int sigsuspend(MemorySegment __set) {
        var mh$ = sigsuspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigsuspend", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigaction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigaction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static FunctionDescriptor sigaction$descriptor() {
        return sigaction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MethodHandle sigaction$handle() {
        return sigaction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static MemorySegment sigaction$address() {
        return sigaction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaction(int __sig, const struct sigaction *restrict __act, struct sigaction *restrict __oact)
     * }
     */
    public static int sigaction(int __sig, MemorySegment __act, MemorySegment __oact) {
        var mh$ = sigaction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaction", __sig, __act, __oact);
            }
            return (int)mh$.invokeExact(__sig, __act, __oact);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigpending {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigpending");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static FunctionDescriptor sigpending$descriptor() {
        return sigpending.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MethodHandle sigpending$handle() {
        return sigpending.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static MemorySegment sigpending$address() {
        return sigpending.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigpending(sigset_t *__set)
     * }
     */
    public static int sigpending(MemorySegment __set) {
        var mh$ = sigpending.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigpending", __set);
            }
            return (int)mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static FunctionDescriptor sigwait$descriptor() {
        return sigwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MethodHandle sigwait$handle() {
        return sigwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static MemorySegment sigwait$address() {
        return sigwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwait(const sigset_t *restrict __set, int *restrict __sig)
     * }
     */
    public static int sigwait(MemorySegment __set, MemorySegment __sig) {
        var mh$ = sigwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwait", __set, __sig);
            }
            return (int)mh$.invokeExact(__set, __sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigwaitinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigwaitinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static FunctionDescriptor sigwaitinfo$descriptor() {
        return sigwaitinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MethodHandle sigwaitinfo$handle() {
        return sigwaitinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static MemorySegment sigwaitinfo$address() {
        return sigwaitinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigwaitinfo(const sigset_t *restrict __set, siginfo_t *restrict __info)
     * }
     */
    public static int sigwaitinfo(MemorySegment __set, MemorySegment __info) {
        var mh$ = sigwaitinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigwaitinfo", __set, __info);
            }
            return (int)mh$.invokeExact(__set, __info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigtimedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigtimedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static FunctionDescriptor sigtimedwait$descriptor() {
        return sigtimedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MethodHandle sigtimedwait$handle() {
        return sigtimedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static MemorySegment sigtimedwait$address() {
        return sigtimedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigtimedwait(const sigset_t *restrict __set, siginfo_t *restrict __info, const struct timespec *restrict __timeout)
     * }
     */
    public static int sigtimedwait(MemorySegment __set, MemorySegment __info, MemorySegment __timeout) {
        var mh$ = sigtimedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigtimedwait", __set, __info, __timeout);
            }
            return (int)mh$.invokeExact(__set, __info, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigqueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            sigval.layout()
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigqueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static FunctionDescriptor sigqueue$descriptor() {
        return sigqueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MethodHandle sigqueue$handle() {
        return sigqueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static MemorySegment sigqueue$address() {
        return sigqueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigqueue(__pid_t __pid, int __sig, const union sigval __val)
     * }
     */
    public static int sigqueue(int __pid, int __sig, MemorySegment __val) {
        var mh$ = sigqueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigqueue", __pid, __sig, __val);
            }
            return (int)mh$.invokeExact(__pid, __sig, __val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static FunctionDescriptor sigreturn$descriptor() {
        return sigreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MethodHandle sigreturn$handle() {
        return sigreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static MemorySegment sigreturn$address() {
        return sigreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigreturn(struct sigcontext *__scp)
     * }
     */
    public static int sigreturn(MemorySegment __scp) {
        var mh$ = sigreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigreturn", __scp);
            }
            return (int)mh$.invokeExact(__scp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long greg_t
     * }
     */
    public static final OfLong greg_t = liburingtest.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _libc_fpstate {
     *     __uint16_t cwd;
     *     __uint16_t swd;
     *     __uint16_t ftw;
     *     __uint16_t fop;
     *     __uint64_t rip;
     *     __uint64_t rdp;
     *     __uint32_t mxcsr;
     *     __uint32_t mxcr_mask;
     *     struct _libc_fpxreg _st[8];
     *     struct _libc_xmmreg _xmm[16];
     *     __uint32_t __glibc_reserved1[24];
     * } *fpregset_t
     * }
     */
    public static final AddressLayout fpregset_t = liburingtest.C_POINTER;

    private static class siginterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("siginterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static FunctionDescriptor siginterrupt$descriptor() {
        return siginterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MethodHandle siginterrupt$handle() {
        return siginterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static MemorySegment siginterrupt$address() {
        return siginterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int siginterrupt(int __sig, int __interrupt)
     * }
     */
    public static int siginterrupt(int __sig, int __interrupt) {
        var mh$ = siginterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("siginterrupt", __sig, __interrupt);
            }
            return (int)mh$.invokeExact(__sig, __interrupt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_ONSTACK = 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SS_DISABLE = 2
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }

    private static class sigaltstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigaltstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static FunctionDescriptor sigaltstack$descriptor() {
        return sigaltstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MethodHandle sigaltstack$handle() {
        return sigaltstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static MemorySegment sigaltstack$address() {
        return sigaltstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigaltstack(const stack_t *restrict __ss, stack_t *restrict __oss)
     * }
     */
    public static int sigaltstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigaltstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigaltstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sigstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sigstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static FunctionDescriptor sigstack$descriptor() {
        return sigstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MethodHandle sigstack$handle() {
        return sigstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static MemorySegment sigstack$address() {
        return sigstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sigstack(struct sigstack *__ss, struct sigstack *__oss)
     * }
     */
    public static int sigstack(MemorySegment __ss, MemorySegment __oss) {
        var mh$ = sigstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sigstack", __ss, __oss);
            }
            return (int)mh$.invokeExact(__ss, __oss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_sigmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("pthread_sigmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static FunctionDescriptor pthread_sigmask$descriptor() {
        return pthread_sigmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MethodHandle pthread_sigmask$handle() {
        return pthread_sigmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static MemorySegment pthread_sigmask$address() {
        return pthread_sigmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_sigmask(int __how, const __sigset_t *restrict __newmask, __sigset_t *restrict __oldmask)
     * }
     */
    public static int pthread_sigmask(int __how, MemorySegment __newmask, MemorySegment __oldmask) {
        var mh$ = pthread_sigmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_sigmask", __how, __newmask, __oldmask);
            }
            return (int)mh$.invokeExact(__how, __newmask, __oldmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("pthread_kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static FunctionDescriptor pthread_kill$descriptor() {
        return pthread_kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MethodHandle pthread_kill$handle() {
        return pthread_kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static MemorySegment pthread_kill$address() {
        return pthread_kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_kill(pthread_t __threadid, int __signo)
     * }
     */
    public static int pthread_kill(long __threadid, int __signo) {
        var mh$ = pthread_kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_kill", __threadid, __signo);
            }
            return (int)mh$.invokeExact(__threadid, __signo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__libc_current_sigrtmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmin$descriptor() {
        return __libc_current_sigrtmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MethodHandle __libc_current_sigrtmin$handle() {
        return __libc_current_sigrtmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static MemorySegment __libc_current_sigrtmin$address() {
        return __libc_current_sigrtmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmin()
     * }
     */
    public static int __libc_current_sigrtmin() {
        var mh$ = __libc_current_sigrtmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmin");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __libc_current_sigrtmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__libc_current_sigrtmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static FunctionDescriptor __libc_current_sigrtmax$descriptor() {
        return __libc_current_sigrtmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MethodHandle __libc_current_sigrtmax$handle() {
        return __libc_current_sigrtmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static MemorySegment __libc_current_sigrtmax$address() {
        return __libc_current_sigrtmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __libc_current_sigrtmax()
     * }
     */
    public static int __libc_current_sigrtmax() {
        var mh$ = __libc_current_sigrtmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__libc_current_sigrtmax");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = liburingtest.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            liburingtest.C_LONG,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = liburingtest.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = liburingtest.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_DOUBLE,
            liburingtest.C_LONG,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, liburingtest.C_POINTER);
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = liburingtest.C_INT;
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = liburingtest.C_LONG;
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, liburingtest.C_POINTER);
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = liburingtest.C_INT;
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = liburingtest.C_LONG;
        public static final MemorySegment SEGMENT = liburingtest.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fcntl(int __fd, int __cmd, ...)
     * }
     */
    public static class fcntl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                liburingtest.C_INT,
                liburingtest.C_INT,
                liburingtest.C_INT
            );
        private static final MemorySegment ADDR = liburingtest.findOrThrow("fcntl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fcntl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fcntl(int __fd, int __cmd, ...)
         * }
         */
        public static fcntl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fcntl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, int __cmd, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fcntl", __fd, __cmd, x2);
                }
                return (int)spreader.invokeExact(__fd, __cmd, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int open(const char *__file, int __oflag, ...)
     * }
     */
    public static class open {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                liburingtest.C_INT,
                liburingtest.C_POINTER,
                liburingtest.C_INT
            );
        private static final MemorySegment ADDR = liburingtest.findOrThrow("open");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private open(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int open(const char *__file, int __oflag, ...)
         * }
         */
        public static open makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new open(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, int __oflag, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("open", __file, __oflag, x2);
                }
                return (int)spreader.invokeExact(__file, __oflag, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int openat(int __fd, const char *__file, int __oflag, ...)
     * }
     */
    public static class openat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                liburingtest.C_INT,
                liburingtest.C_INT,
                liburingtest.C_POINTER,
                liburingtest.C_INT
            );
        private static final MemorySegment ADDR = liburingtest.findOrThrow("openat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private openat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int openat(int __fd, const char *__file, int __oflag, ...)
         * }
         */
        public static openat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new openat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __file, int __oflag, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("openat", __fd, __file, __oflag, x3);
                }
                return (int)spreader.invokeExact(__fd, __file, __oflag, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class creat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("creat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static FunctionDescriptor creat$descriptor() {
        return creat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static MethodHandle creat$handle() {
        return creat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static MemorySegment creat$address() {
        return creat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int creat(const char *__file, mode_t __mode)
     * }
     */
    public static int creat(MemorySegment __file, int __mode) {
        var mh$ = creat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creat", __file, __mode);
            }
            return (int)mh$.invokeExact(__file, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, off_t __len)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, off_t __len)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, off_t __len)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lockf(int __fd, int __cmd, off_t __len)
     * }
     */
    public static int lockf(int __fd, int __cmd, long __len) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", __fd, __cmd, __len);
            }
            return (int)mh$.invokeExact(__fd, __cmd, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_fadvise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("posix_fadvise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static FunctionDescriptor posix_fadvise$descriptor() {
        return posix_fadvise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static MethodHandle posix_fadvise$handle() {
        return posix_fadvise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static MemorySegment posix_fadvise$address() {
        return posix_fadvise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_fadvise(int __fd, off_t __offset, off_t __len, int __advise)
     * }
     */
    public static int posix_fadvise(int __fd, long __offset, long __len, int __advise) {
        var mh$ = posix_fadvise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_fadvise", __fd, __offset, __len, __advise);
            }
            return (int)mh$.invokeExact(__fd, __offset, __len, __advise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_fallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("posix_fallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static FunctionDescriptor posix_fallocate$descriptor() {
        return posix_fallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static MethodHandle posix_fallocate$handle() {
        return posix_fallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static MemorySegment posix_fallocate$address() {
        return posix_fallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_fallocate(int __fd, off_t __offset, off_t __len)
     * }
     */
    public static int posix_fallocate(int __fd, long __offset, long __len) {
        var mh$ = posix_fallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_fallocate", __fd, __offset, __len);
            }
            return (int)mh$.invokeExact(__fd, __offset, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = liburingtest.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __s8
     * }
     */
    public static final OfByte __s8 = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u8
     * }
     */
    public static final OfByte __u8 = liburingtest.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __s16
     * }
     */
    public static final OfShort __s16 = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u16
     * }
     */
    public static final OfShort __u16 = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __s32
     * }
     */
    public static final OfInt __s32 = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u32
     * }
     */
    public static final OfInt __u32 = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __s64
     * }
     */
    public static final OfLong __s64 = liburingtest.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __u64
     * }
     */
    public static final OfLong __u64 = liburingtest.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u16 __le16
     * }
     */
    public static final OfShort __le16 = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u16 __be16
     * }
     */
    public static final OfShort __be16 = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __le32
     * }
     */
    public static final OfInt __le32 = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __be32
     * }
     */
    public static final OfInt __be32 = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u64 __le64
     * }
     */
    public static final OfLong __le64 = liburingtest.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u64 __be64
     * }
     */
    public static final OfLong __be64 = liburingtest.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u16 __sum16
     * }
     */
    public static final OfShort __sum16 = liburingtest.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __wsum
     * }
     */
    public static final OfInt __wsum = liburingtest.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __poll_t
     * }
     */
    public static final OfInt __poll_t = liburingtest.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait(int *__stat_loc)
     * }
     */
    public static int wait(MemorySegment __stat_loc) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", __stat_loc);
            }
            return (int)mh$.invokeExact(__stat_loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options)
     * }
     */
    public static int waitpid(int __pid, MemorySegment __stat_loc, int __options) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", __pid, __stat_loc, __options);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int waitid(idtype_t __idtype, __id_t __id, siginfo_t *__infop, int __options)
     * }
     */
    public static int waitid(int __idtype, int __id, MemorySegment __infop, int __options) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", __idtype, __id, __infop, __options);
            }
            return (int)mh$.invokeExact(__idtype, __id, __infop, __options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait3(int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait3(MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__stat_loc, __options, __usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __pid_t wait4(__pid_t __pid, int *__stat_loc, int __options, struct rusage *__usage)
     * }
     */
    public static int wait4(int __pid, MemorySegment __stat_loc, int __options, MemorySegment __usage) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", __pid, __stat_loc, __options, __usage);
            }
            return (int)mh$.invokeExact(__pid, __stat_loc, __options, __usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FSCONFIG_SET_FLAG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_FLAG = 0
     * }
     */
    public static int FSCONFIG_SET_FLAG() {
        return FSCONFIG_SET_FLAG;
    }
    private static final int FSCONFIG_SET_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_STRING = 1
     * }
     */
    public static int FSCONFIG_SET_STRING() {
        return FSCONFIG_SET_STRING;
    }
    private static final int FSCONFIG_SET_BINARY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_BINARY = 2
     * }
     */
    public static int FSCONFIG_SET_BINARY() {
        return FSCONFIG_SET_BINARY;
    }
    private static final int FSCONFIG_SET_PATH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_PATH = 3
     * }
     */
    public static int FSCONFIG_SET_PATH() {
        return FSCONFIG_SET_PATH;
    }
    private static final int FSCONFIG_SET_PATH_EMPTY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_PATH_EMPTY = 4
     * }
     */
    public static int FSCONFIG_SET_PATH_EMPTY() {
        return FSCONFIG_SET_PATH_EMPTY;
    }
    private static final int FSCONFIG_SET_FD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_SET_FD = 5
     * }
     */
    public static int FSCONFIG_SET_FD() {
        return FSCONFIG_SET_FD;
    }
    private static final int FSCONFIG_CMD_CREATE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_CREATE = 6
     * }
     */
    public static int FSCONFIG_CMD_CREATE() {
        return FSCONFIG_CMD_CREATE;
    }
    private static final int FSCONFIG_CMD_RECONFIGURE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_RECONFIGURE = 7
     * }
     */
    public static int FSCONFIG_CMD_RECONFIGURE() {
        return FSCONFIG_CMD_RECONFIGURE;
    }
    private static final int FSCONFIG_CMD_CREATE_EXCL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum fsconfig_command.FSCONFIG_CMD_CREATE_EXCL = 8
     * }
     */
    public static int FSCONFIG_CMD_CREATE_EXCL() {
        return FSCONFIG_CMD_CREATE_EXCL;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_rwf_t
     * }
     */
    public static final OfInt __kernel_rwf_t = liburingtest.C_INT;
    private static final int IOSQE_FIXED_FILE_BIT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_FIXED_FILE_BIT = 0
     * }
     */
    public static int IOSQE_FIXED_FILE_BIT() {
        return IOSQE_FIXED_FILE_BIT;
    }
    private static final int IOSQE_IO_DRAIN_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_DRAIN_BIT = 1
     * }
     */
    public static int IOSQE_IO_DRAIN_BIT() {
        return IOSQE_IO_DRAIN_BIT;
    }
    private static final int IOSQE_IO_LINK_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_LINK_BIT = 2
     * }
     */
    public static int IOSQE_IO_LINK_BIT() {
        return IOSQE_IO_LINK_BIT;
    }
    private static final int IOSQE_IO_HARDLINK_BIT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_IO_HARDLINK_BIT = 3
     * }
     */
    public static int IOSQE_IO_HARDLINK_BIT() {
        return IOSQE_IO_HARDLINK_BIT;
    }
    private static final int IOSQE_ASYNC_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_ASYNC_BIT = 4
     * }
     */
    public static int IOSQE_ASYNC_BIT() {
        return IOSQE_ASYNC_BIT;
    }
    private static final int IOSQE_BUFFER_SELECT_BIT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_BUFFER_SELECT_BIT = 5
     * }
     */
    public static int IOSQE_BUFFER_SELECT_BIT() {
        return IOSQE_BUFFER_SELECT_BIT;
    }
    private static final int IOSQE_CQE_SKIP_SUCCESS_BIT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_sqe_flags_bit.IOSQE_CQE_SKIP_SUCCESS_BIT = 6
     * }
     */
    public static int IOSQE_CQE_SKIP_SUCCESS_BIT() {
        return IOSQE_CQE_SKIP_SUCCESS_BIT;
    }
    private static final int IORING_OP_NOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_NOP = 0
     * }
     */
    public static int IORING_OP_NOP() {
        return IORING_OP_NOP;
    }
    private static final int IORING_OP_READV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READV = 1
     * }
     */
    public static int IORING_OP_READV() {
        return IORING_OP_READV;
    }
    private static final int IORING_OP_WRITEV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITEV = 2
     * }
     */
    public static int IORING_OP_WRITEV() {
        return IORING_OP_WRITEV;
    }
    private static final int IORING_OP_FSYNC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FSYNC = 3
     * }
     */
    public static int IORING_OP_FSYNC() {
        return IORING_OP_FSYNC;
    }
    private static final int IORING_OP_READ_FIXED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ_FIXED = 4
     * }
     */
    public static int IORING_OP_READ_FIXED() {
        return IORING_OP_READ_FIXED;
    }
    private static final int IORING_OP_WRITE_FIXED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITE_FIXED = 5
     * }
     */
    public static int IORING_OP_WRITE_FIXED() {
        return IORING_OP_WRITE_FIXED;
    }
    private static final int IORING_OP_POLL_ADD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_POLL_ADD = 6
     * }
     */
    public static int IORING_OP_POLL_ADD() {
        return IORING_OP_POLL_ADD;
    }
    private static final int IORING_OP_POLL_REMOVE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_POLL_REMOVE = 7
     * }
     */
    public static int IORING_OP_POLL_REMOVE() {
        return IORING_OP_POLL_REMOVE;
    }
    private static final int IORING_OP_SYNC_FILE_RANGE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SYNC_FILE_RANGE = 8
     * }
     */
    public static int IORING_OP_SYNC_FILE_RANGE() {
        return IORING_OP_SYNC_FILE_RANGE;
    }
    private static final int IORING_OP_SENDMSG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SENDMSG = 9
     * }
     */
    public static int IORING_OP_SENDMSG() {
        return IORING_OP_SENDMSG;
    }
    private static final int IORING_OP_RECVMSG = (int)10L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RECVMSG = 10
     * }
     */
    public static int IORING_OP_RECVMSG() {
        return IORING_OP_RECVMSG;
    }
    private static final int IORING_OP_TIMEOUT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TIMEOUT = 11
     * }
     */
    public static int IORING_OP_TIMEOUT() {
        return IORING_OP_TIMEOUT;
    }
    private static final int IORING_OP_TIMEOUT_REMOVE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TIMEOUT_REMOVE = 12
     * }
     */
    public static int IORING_OP_TIMEOUT_REMOVE() {
        return IORING_OP_TIMEOUT_REMOVE;
    }
    private static final int IORING_OP_ACCEPT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_ACCEPT = 13
     * }
     */
    public static int IORING_OP_ACCEPT() {
        return IORING_OP_ACCEPT;
    }
    private static final int IORING_OP_ASYNC_CANCEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_ASYNC_CANCEL = 14
     * }
     */
    public static int IORING_OP_ASYNC_CANCEL() {
        return IORING_OP_ASYNC_CANCEL;
    }
    private static final int IORING_OP_LINK_TIMEOUT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LINK_TIMEOUT = 15
     * }
     */
    public static int IORING_OP_LINK_TIMEOUT() {
        return IORING_OP_LINK_TIMEOUT;
    }
    private static final int IORING_OP_CONNECT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_CONNECT = 16
     * }
     */
    public static int IORING_OP_CONNECT() {
        return IORING_OP_CONNECT;
    }
    private static final int IORING_OP_FALLOCATE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FALLOCATE = 17
     * }
     */
    public static int IORING_OP_FALLOCATE() {
        return IORING_OP_FALLOCATE;
    }
    private static final int IORING_OP_OPENAT = (int)18L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_OPENAT = 18
     * }
     */
    public static int IORING_OP_OPENAT() {
        return IORING_OP_OPENAT;
    }
    private static final int IORING_OP_CLOSE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_CLOSE = 19
     * }
     */
    public static int IORING_OP_CLOSE() {
        return IORING_OP_CLOSE;
    }
    private static final int IORING_OP_FILES_UPDATE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FILES_UPDATE = 20
     * }
     */
    public static int IORING_OP_FILES_UPDATE() {
        return IORING_OP_FILES_UPDATE;
    }
    private static final int IORING_OP_STATX = (int)21L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_STATX = 21
     * }
     */
    public static int IORING_OP_STATX() {
        return IORING_OP_STATX;
    }
    private static final int IORING_OP_READ = (int)22L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ = 22
     * }
     */
    public static int IORING_OP_READ() {
        return IORING_OP_READ;
    }
    private static final int IORING_OP_WRITE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WRITE = 23
     * }
     */
    public static int IORING_OP_WRITE() {
        return IORING_OP_WRITE;
    }
    private static final int IORING_OP_FADVISE = (int)24L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FADVISE = 24
     * }
     */
    public static int IORING_OP_FADVISE() {
        return IORING_OP_FADVISE;
    }
    private static final int IORING_OP_MADVISE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MADVISE = 25
     * }
     */
    public static int IORING_OP_MADVISE() {
        return IORING_OP_MADVISE;
    }
    private static final int IORING_OP_SEND = (int)26L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SEND = 26
     * }
     */
    public static int IORING_OP_SEND() {
        return IORING_OP_SEND;
    }
    private static final int IORING_OP_RECV = (int)27L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RECV = 27
     * }
     */
    public static int IORING_OP_RECV() {
        return IORING_OP_RECV;
    }
    private static final int IORING_OP_OPENAT2 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_OPENAT2 = 28
     * }
     */
    public static int IORING_OP_OPENAT2() {
        return IORING_OP_OPENAT2;
    }
    private static final int IORING_OP_EPOLL_CTL = (int)29L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_EPOLL_CTL = 29
     * }
     */
    public static int IORING_OP_EPOLL_CTL() {
        return IORING_OP_EPOLL_CTL;
    }
    private static final int IORING_OP_SPLICE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SPLICE = 30
     * }
     */
    public static int IORING_OP_SPLICE() {
        return IORING_OP_SPLICE;
    }
    private static final int IORING_OP_PROVIDE_BUFFERS = (int)31L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_PROVIDE_BUFFERS = 31
     * }
     */
    public static int IORING_OP_PROVIDE_BUFFERS() {
        return IORING_OP_PROVIDE_BUFFERS;
    }
    private static final int IORING_OP_REMOVE_BUFFERS = (int)32L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_REMOVE_BUFFERS = 32
     * }
     */
    public static int IORING_OP_REMOVE_BUFFERS() {
        return IORING_OP_REMOVE_BUFFERS;
    }
    private static final int IORING_OP_TEE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_TEE = 33
     * }
     */
    public static int IORING_OP_TEE() {
        return IORING_OP_TEE;
    }
    private static final int IORING_OP_SHUTDOWN = (int)34L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SHUTDOWN = 34
     * }
     */
    public static int IORING_OP_SHUTDOWN() {
        return IORING_OP_SHUTDOWN;
    }
    private static final int IORING_OP_RENAMEAT = (int)35L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_RENAMEAT = 35
     * }
     */
    public static int IORING_OP_RENAMEAT() {
        return IORING_OP_RENAMEAT;
    }
    private static final int IORING_OP_UNLINKAT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_UNLINKAT = 36
     * }
     */
    public static int IORING_OP_UNLINKAT() {
        return IORING_OP_UNLINKAT;
    }
    private static final int IORING_OP_MKDIRAT = (int)37L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MKDIRAT = 37
     * }
     */
    public static int IORING_OP_MKDIRAT() {
        return IORING_OP_MKDIRAT;
    }
    private static final int IORING_OP_SYMLINKAT = (int)38L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SYMLINKAT = 38
     * }
     */
    public static int IORING_OP_SYMLINKAT() {
        return IORING_OP_SYMLINKAT;
    }
    private static final int IORING_OP_LINKAT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LINKAT = 39
     * }
     */
    public static int IORING_OP_LINKAT() {
        return IORING_OP_LINKAT;
    }
    private static final int IORING_OP_MSG_RING = (int)40L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_MSG_RING = 40
     * }
     */
    public static int IORING_OP_MSG_RING() {
        return IORING_OP_MSG_RING;
    }
    private static final int IORING_OP_FSETXATTR = (int)41L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FSETXATTR = 41
     * }
     */
    public static int IORING_OP_FSETXATTR() {
        return IORING_OP_FSETXATTR;
    }
    private static final int IORING_OP_SETXATTR = (int)42L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SETXATTR = 42
     * }
     */
    public static int IORING_OP_SETXATTR() {
        return IORING_OP_SETXATTR;
    }
    private static final int IORING_OP_FGETXATTR = (int)43L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FGETXATTR = 43
     * }
     */
    public static int IORING_OP_FGETXATTR() {
        return IORING_OP_FGETXATTR;
    }
    private static final int IORING_OP_GETXATTR = (int)44L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_GETXATTR = 44
     * }
     */
    public static int IORING_OP_GETXATTR() {
        return IORING_OP_GETXATTR;
    }
    private static final int IORING_OP_SOCKET = (int)45L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SOCKET = 45
     * }
     */
    public static int IORING_OP_SOCKET() {
        return IORING_OP_SOCKET;
    }
    private static final int IORING_OP_URING_CMD = (int)46L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_URING_CMD = 46
     * }
     */
    public static int IORING_OP_URING_CMD() {
        return IORING_OP_URING_CMD;
    }
    private static final int IORING_OP_SEND_ZC = (int)47L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SEND_ZC = 47
     * }
     */
    public static int IORING_OP_SEND_ZC() {
        return IORING_OP_SEND_ZC;
    }
    private static final int IORING_OP_SENDMSG_ZC = (int)48L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_SENDMSG_ZC = 48
     * }
     */
    public static int IORING_OP_SENDMSG_ZC() {
        return IORING_OP_SENDMSG_ZC;
    }
    private static final int IORING_OP_READ_MULTISHOT = (int)49L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_READ_MULTISHOT = 49
     * }
     */
    public static int IORING_OP_READ_MULTISHOT() {
        return IORING_OP_READ_MULTISHOT;
    }
    private static final int IORING_OP_WAITID = (int)50L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_WAITID = 50
     * }
     */
    public static int IORING_OP_WAITID() {
        return IORING_OP_WAITID;
    }
    private static final int IORING_OP_FUTEX_WAIT = (int)51L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAIT = 51
     * }
     */
    public static int IORING_OP_FUTEX_WAIT() {
        return IORING_OP_FUTEX_WAIT;
    }
    private static final int IORING_OP_FUTEX_WAKE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAKE = 52
     * }
     */
    public static int IORING_OP_FUTEX_WAKE() {
        return IORING_OP_FUTEX_WAKE;
    }
    private static final int IORING_OP_FUTEX_WAITV = (int)53L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FUTEX_WAITV = 53
     * }
     */
    public static int IORING_OP_FUTEX_WAITV() {
        return IORING_OP_FUTEX_WAITV;
    }
    private static final int IORING_OP_FIXED_FD_INSTALL = (int)54L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FIXED_FD_INSTALL = 54
     * }
     */
    public static int IORING_OP_FIXED_FD_INSTALL() {
        return IORING_OP_FIXED_FD_INSTALL;
    }
    private static final int IORING_OP_FTRUNCATE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_FTRUNCATE = 55
     * }
     */
    public static int IORING_OP_FTRUNCATE() {
        return IORING_OP_FTRUNCATE;
    }
    private static final int IORING_OP_BIND = (int)56L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_BIND = 56
     * }
     */
    public static int IORING_OP_BIND() {
        return IORING_OP_BIND;
    }
    private static final int IORING_OP_LISTEN = (int)57L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LISTEN = 57
     * }
     */
    public static int IORING_OP_LISTEN() {
        return IORING_OP_LISTEN;
    }
    private static final int IORING_OP_LAST = (int)58L;
    /**
     * {@snippet lang=c :
     * enum io_uring_op.IORING_OP_LAST = 58
     * }
     */
    public static int IORING_OP_LAST() {
        return IORING_OP_LAST;
    }
    private static final int IORING_MSG_DATA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_msg_ring_flags.IORING_MSG_DATA = 0
     * }
     */
    public static int IORING_MSG_DATA() {
        return IORING_MSG_DATA;
    }
    private static final int IORING_MSG_SEND_FD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_msg_ring_flags.IORING_MSG_SEND_FD = 1
     * }
     */
    public static int IORING_MSG_SEND_FD() {
        return IORING_MSG_SEND_FD;
    }
    private static final int IORING_REGISTER_BUFFERS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS = 0
     * }
     */
    public static int IORING_REGISTER_BUFFERS() {
        return IORING_REGISTER_BUFFERS;
    }
    private static final int IORING_UNREGISTER_BUFFERS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_BUFFERS = 1
     * }
     */
    public static int IORING_UNREGISTER_BUFFERS() {
        return IORING_UNREGISTER_BUFFERS;
    }
    private static final int IORING_REGISTER_FILES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES = 2
     * }
     */
    public static int IORING_REGISTER_FILES() {
        return IORING_REGISTER_FILES;
    }
    private static final int IORING_UNREGISTER_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_FILES = 3
     * }
     */
    public static int IORING_UNREGISTER_FILES() {
        return IORING_UNREGISTER_FILES;
    }
    private static final int IORING_REGISTER_EVENTFD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_EVENTFD = 4
     * }
     */
    public static int IORING_REGISTER_EVENTFD() {
        return IORING_REGISTER_EVENTFD;
    }
    private static final int IORING_UNREGISTER_EVENTFD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_EVENTFD = 5
     * }
     */
    public static int IORING_UNREGISTER_EVENTFD() {
        return IORING_UNREGISTER_EVENTFD;
    }
    private static final int IORING_REGISTER_FILES_UPDATE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES_UPDATE = 6
     * }
     */
    public static int IORING_REGISTER_FILES_UPDATE() {
        return IORING_REGISTER_FILES_UPDATE;
    }
    private static final int IORING_REGISTER_EVENTFD_ASYNC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_EVENTFD_ASYNC = 7
     * }
     */
    public static int IORING_REGISTER_EVENTFD_ASYNC() {
        return IORING_REGISTER_EVENTFD_ASYNC;
    }
    private static final int IORING_REGISTER_PROBE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PROBE = 8
     * }
     */
    public static int IORING_REGISTER_PROBE() {
        return IORING_REGISTER_PROBE;
    }
    private static final int IORING_REGISTER_PERSONALITY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PERSONALITY = 9
     * }
     */
    public static int IORING_REGISTER_PERSONALITY() {
        return IORING_REGISTER_PERSONALITY;
    }
    private static final int IORING_UNREGISTER_PERSONALITY = (int)10L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_PERSONALITY = 10
     * }
     */
    public static int IORING_UNREGISTER_PERSONALITY() {
        return IORING_UNREGISTER_PERSONALITY;
    }
    private static final int IORING_REGISTER_RESTRICTIONS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_RESTRICTIONS = 11
     * }
     */
    public static int IORING_REGISTER_RESTRICTIONS() {
        return IORING_REGISTER_RESTRICTIONS;
    }
    private static final int IORING_REGISTER_ENABLE_RINGS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_ENABLE_RINGS = 12
     * }
     */
    public static int IORING_REGISTER_ENABLE_RINGS() {
        return IORING_REGISTER_ENABLE_RINGS;
    }
    private static final int IORING_REGISTER_FILES2 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES2 = 13
     * }
     */
    public static int IORING_REGISTER_FILES2() {
        return IORING_REGISTER_FILES2;
    }
    private static final int IORING_REGISTER_FILES_UPDATE2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILES_UPDATE2 = 14
     * }
     */
    public static int IORING_REGISTER_FILES_UPDATE2() {
        return IORING_REGISTER_FILES_UPDATE2;
    }
    private static final int IORING_REGISTER_BUFFERS2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS2 = 15
     * }
     */
    public static int IORING_REGISTER_BUFFERS2() {
        return IORING_REGISTER_BUFFERS2;
    }
    private static final int IORING_REGISTER_BUFFERS_UPDATE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_BUFFERS_UPDATE = 16
     * }
     */
    public static int IORING_REGISTER_BUFFERS_UPDATE() {
        return IORING_REGISTER_BUFFERS_UPDATE;
    }
    private static final int IORING_REGISTER_IOWQ_AFF = (int)17L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_IOWQ_AFF = 17
     * }
     */
    public static int IORING_REGISTER_IOWQ_AFF() {
        return IORING_REGISTER_IOWQ_AFF;
    }
    private static final int IORING_UNREGISTER_IOWQ_AFF = (int)18L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_IOWQ_AFF = 18
     * }
     */
    public static int IORING_UNREGISTER_IOWQ_AFF() {
        return IORING_UNREGISTER_IOWQ_AFF;
    }
    private static final int IORING_REGISTER_IOWQ_MAX_WORKERS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_IOWQ_MAX_WORKERS = 19
     * }
     */
    public static int IORING_REGISTER_IOWQ_MAX_WORKERS() {
        return IORING_REGISTER_IOWQ_MAX_WORKERS;
    }
    private static final int IORING_REGISTER_RING_FDS = (int)20L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_RING_FDS = 20
     * }
     */
    public static int IORING_REGISTER_RING_FDS() {
        return IORING_REGISTER_RING_FDS;
    }
    private static final int IORING_UNREGISTER_RING_FDS = (int)21L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_RING_FDS = 21
     * }
     */
    public static int IORING_UNREGISTER_RING_FDS() {
        return IORING_UNREGISTER_RING_FDS;
    }
    private static final int IORING_REGISTER_PBUF_RING = (int)22L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PBUF_RING = 22
     * }
     */
    public static int IORING_REGISTER_PBUF_RING() {
        return IORING_REGISTER_PBUF_RING;
    }
    private static final int IORING_UNREGISTER_PBUF_RING = (int)23L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_PBUF_RING = 23
     * }
     */
    public static int IORING_UNREGISTER_PBUF_RING() {
        return IORING_UNREGISTER_PBUF_RING;
    }
    private static final int IORING_REGISTER_SYNC_CANCEL = (int)24L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_SYNC_CANCEL = 24
     * }
     */
    public static int IORING_REGISTER_SYNC_CANCEL() {
        return IORING_REGISTER_SYNC_CANCEL;
    }
    private static final int IORING_REGISTER_FILE_ALLOC_RANGE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_FILE_ALLOC_RANGE = 25
     * }
     */
    public static int IORING_REGISTER_FILE_ALLOC_RANGE() {
        return IORING_REGISTER_FILE_ALLOC_RANGE;
    }
    private static final int IORING_REGISTER_PBUF_STATUS = (int)26L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_PBUF_STATUS = 26
     * }
     */
    public static int IORING_REGISTER_PBUF_STATUS() {
        return IORING_REGISTER_PBUF_STATUS;
    }
    private static final int IORING_REGISTER_NAPI = (int)27L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_NAPI = 27
     * }
     */
    public static int IORING_REGISTER_NAPI() {
        return IORING_REGISTER_NAPI;
    }
    private static final int IORING_UNREGISTER_NAPI = (int)28L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_UNREGISTER_NAPI = 28
     * }
     */
    public static int IORING_UNREGISTER_NAPI() {
        return IORING_UNREGISTER_NAPI;
    }
    private static final int IORING_REGISTER_CLOCK = (int)29L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_CLOCK = 29
     * }
     */
    public static int IORING_REGISTER_CLOCK() {
        return IORING_REGISTER_CLOCK;
    }
    private static final int IORING_REGISTER_LAST = (int)30L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_LAST = 30
     * }
     */
    public static int IORING_REGISTER_LAST() {
        return IORING_REGISTER_LAST;
    }
    private static final int IORING_REGISTER_USE_REGISTERED_RING = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_op.IORING_REGISTER_USE_REGISTERED_RING = -2147483648
     * }
     */
    public static int IORING_REGISTER_USE_REGISTERED_RING() {
        return IORING_REGISTER_USE_REGISTERED_RING;
    }
    private static final int IO_WQ_BOUND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_wq_type.IO_WQ_BOUND = 0
     * }
     */
    public static int IO_WQ_BOUND() {
        return IO_WQ_BOUND;
    }
    private static final int IO_WQ_UNBOUND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_wq_type.IO_WQ_UNBOUND = 1
     * }
     */
    public static int IO_WQ_UNBOUND() {
        return IO_WQ_UNBOUND;
    }
    private static final int IOU_PBUF_RING_MMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_pbuf_ring_flags.IOU_PBUF_RING_MMAP = 1
     * }
     */
    public static int IOU_PBUF_RING_MMAP() {
        return IOU_PBUF_RING_MMAP;
    }
    private static final int IORING_RESTRICTION_REGISTER_OP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_restriction_op.IORING_RESTRICTION_REGISTER_OP = 0
     * }
     */
    public static int IORING_RESTRICTION_REGISTER_OP() {
        return IORING_RESTRICTION_REGISTER_OP;
    }
    private static final int IORING_RESTRICTION_SQE_OP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_restriction_op.IORING_RESTRICTION_SQE_OP = 1
     * }
     */
    public static int IORING_RESTRICTION_SQE_OP() {
        return IORING_RESTRICTION_SQE_OP;
    }
    private static final int IORING_RESTRICTION_SQE_FLAGS_ALLOWED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_restriction_op.IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2
     * }
     */
    public static int IORING_RESTRICTION_SQE_FLAGS_ALLOWED() {
        return IORING_RESTRICTION_SQE_FLAGS_ALLOWED;
    }
    private static final int IORING_RESTRICTION_SQE_FLAGS_REQUIRED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_restriction_op.IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3
     * }
     */
    public static int IORING_RESTRICTION_SQE_FLAGS_REQUIRED() {
        return IORING_RESTRICTION_SQE_FLAGS_REQUIRED;
    }
    private static final int IORING_RESTRICTION_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum io_uring_register_restriction_op.IORING_RESTRICTION_LAST = 4
     * }
     */
    public static int IORING_RESTRICTION_LAST() {
        return IORING_RESTRICTION_LAST;
    }
    private static final int SOCKET_URING_OP_SIOCINQ = (int)0L;
    /**
     * {@snippet lang=c :
     * enum io_uring_socket_op.SOCKET_URING_OP_SIOCINQ = 0
     * }
     */
    public static int SOCKET_URING_OP_SIOCINQ() {
        return SOCKET_URING_OP_SIOCINQ;
    }
    private static final int SOCKET_URING_OP_SIOCOUTQ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum io_uring_socket_op.SOCKET_URING_OP_SIOCOUTQ = 1
     * }
     */
    public static int SOCKET_URING_OP_SIOCOUTQ() {
        return SOCKET_URING_OP_SIOCOUTQ;
    }
    private static final int SOCKET_URING_OP_GETSOCKOPT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum io_uring_socket_op.SOCKET_URING_OP_GETSOCKOPT = 2
     * }
     */
    public static int SOCKET_URING_OP_GETSOCKOPT() {
        return SOCKET_URING_OP_GETSOCKOPT;
    }
    private static final int SOCKET_URING_OP_SETSOCKOPT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum io_uring_socket_op.SOCKET_URING_OP_SETSOCKOPT = 3
     * }
     */
    public static int SOCKET_URING_OP_SETSOCKOPT() {
        return SOCKET_URING_OP_SETSOCKOPT;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = liburingtest.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = liburingtest.C_INT;
    private static final int memory_order_relaxed = (int)0L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_relaxed = 0
     * }
     */
    public static int memory_order_relaxed() {
        return memory_order_relaxed;
    }
    private static final int memory_order_consume = (int)1L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_consume = 1
     * }
     */
    public static int memory_order_consume() {
        return memory_order_consume;
    }
    private static final int memory_order_acquire = (int)2L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_acquire = 2
     * }
     */
    public static int memory_order_acquire() {
        return memory_order_acquire;
    }
    private static final int memory_order_release = (int)3L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_release = 3
     * }
     */
    public static int memory_order_release() {
        return memory_order_release;
    }
    private static final int memory_order_acq_rel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_acq_rel = 4
     * }
     */
    public static int memory_order_acq_rel() {
        return memory_order_acq_rel;
    }
    private static final int memory_order_seq_cst = (int)5L;
    /**
     * {@snippet lang=c :
     * enum memory_order.memory_order_seq_cst = 5
     * }
     */
    public static int memory_order_seq_cst() {
        return memory_order_seq_cst;
    }

    private static class atomic_thread_fence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_thread_fence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void atomic_thread_fence(memory_order)
     * }
     */
    public static FunctionDescriptor atomic_thread_fence$descriptor() {
        return atomic_thread_fence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void atomic_thread_fence(memory_order)
     * }
     */
    public static MethodHandle atomic_thread_fence$handle() {
        return atomic_thread_fence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void atomic_thread_fence(memory_order)
     * }
     */
    public static MemorySegment atomic_thread_fence$address() {
        return atomic_thread_fence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void atomic_thread_fence(memory_order)
     * }
     */
    public static void atomic_thread_fence(int x0) {
        var mh$ = atomic_thread_fence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_thread_fence", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atomic_signal_fence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_signal_fence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void atomic_signal_fence(memory_order)
     * }
     */
    public static FunctionDescriptor atomic_signal_fence$descriptor() {
        return atomic_signal_fence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void atomic_signal_fence(memory_order)
     * }
     */
    public static MethodHandle atomic_signal_fence$handle() {
        return atomic_signal_fence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void atomic_signal_fence(memory_order)
     * }
     */
    public static MemorySegment atomic_signal_fence$address() {
        return atomic_signal_fence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void atomic_signal_fence(memory_order)
     * }
     */
    public static void atomic_signal_fence(int x0) {
        var mh$ = atomic_signal_fence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_signal_fence", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atomic_flag_test_and_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_BOOL,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_flag_test_and_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set(volatile atomic_flag *)
     * }
     */
    public static FunctionDescriptor atomic_flag_test_and_set$descriptor() {
        return atomic_flag_test_and_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set(volatile atomic_flag *)
     * }
     */
    public static MethodHandle atomic_flag_test_and_set$handle() {
        return atomic_flag_test_and_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set(volatile atomic_flag *)
     * }
     */
    public static MemorySegment atomic_flag_test_and_set$address() {
        return atomic_flag_test_and_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set(volatile atomic_flag *)
     * }
     */
    public static boolean atomic_flag_test_and_set(MemorySegment x0) {
        var mh$ = atomic_flag_test_and_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_flag_test_and_set", x0);
            }
            return (boolean)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atomic_flag_test_and_set_explicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_BOOL,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_flag_test_and_set_explicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static FunctionDescriptor atomic_flag_test_and_set_explicit$descriptor() {
        return atomic_flag_test_and_set_explicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static MethodHandle atomic_flag_test_and_set_explicit$handle() {
        return atomic_flag_test_and_set_explicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static MemorySegment atomic_flag_test_and_set_explicit$address() {
        return atomic_flag_test_and_set_explicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool atomic_flag_test_and_set_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static boolean atomic_flag_test_and_set_explicit(MemorySegment x0, int x1) {
        var mh$ = atomic_flag_test_and_set_explicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_flag_test_and_set_explicit", x0, x1);
            }
            return (boolean)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atomic_flag_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_flag_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void atomic_flag_clear(volatile atomic_flag *)
     * }
     */
    public static FunctionDescriptor atomic_flag_clear$descriptor() {
        return atomic_flag_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void atomic_flag_clear(volatile atomic_flag *)
     * }
     */
    public static MethodHandle atomic_flag_clear$handle() {
        return atomic_flag_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void atomic_flag_clear(volatile atomic_flag *)
     * }
     */
    public static MemorySegment atomic_flag_clear$address() {
        return atomic_flag_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void atomic_flag_clear(volatile atomic_flag *)
     * }
     */
    public static void atomic_flag_clear(MemorySegment x0) {
        var mh$ = atomic_flag_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_flag_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atomic_flag_clear_explicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("atomic_flag_clear_explicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void atomic_flag_clear_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static FunctionDescriptor atomic_flag_clear_explicit$descriptor() {
        return atomic_flag_clear_explicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void atomic_flag_clear_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static MethodHandle atomic_flag_clear_explicit$handle() {
        return atomic_flag_clear_explicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void atomic_flag_clear_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static MemorySegment atomic_flag_clear_explicit$address() {
        return atomic_flag_clear_explicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void atomic_flag_clear_explicit(volatile atomic_flag *, memory_order)
     * }
     */
    public static void atomic_flag_clear_explicit(MemorySegment x0, int x1) {
        var mh$ = atomic_flag_clear_explicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atomic_flag_clear_explicit", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_get_probe_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_get_probe_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe_ring(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_get_probe_ring$descriptor() {
        return io_uring_get_probe_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe_ring(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_get_probe_ring$handle() {
        return io_uring_get_probe_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe_ring(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_get_probe_ring$address() {
        return io_uring_get_probe_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe_ring(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_get_probe_ring(MemorySegment ring) {
        var mh$ = io_uring_get_probe_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_get_probe_ring", ring);
            }
            return (MemorySegment)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_get_probe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_get_probe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe()
     * }
     */
    public static FunctionDescriptor io_uring_get_probe$descriptor() {
        return io_uring_get_probe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe()
     * }
     */
    public static MethodHandle io_uring_get_probe$handle() {
        return io_uring_get_probe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe()
     * }
     */
    public static MemorySegment io_uring_get_probe$address() {
        return io_uring_get_probe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct io_uring_probe *io_uring_get_probe()
     * }
     */
    public static MemorySegment io_uring_get_probe() {
        var mh$ = io_uring_get_probe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_get_probe");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_free_probe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_free_probe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void io_uring_free_probe(struct io_uring_probe *probe)
     * }
     */
    public static FunctionDescriptor io_uring_free_probe$descriptor() {
        return io_uring_free_probe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void io_uring_free_probe(struct io_uring_probe *probe)
     * }
     */
    public static MethodHandle io_uring_free_probe$handle() {
        return io_uring_free_probe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void io_uring_free_probe(struct io_uring_probe *probe)
     * }
     */
    public static MemorySegment io_uring_free_probe$address() {
        return io_uring_free_probe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void io_uring_free_probe(struct io_uring_probe *probe)
     * }
     */
    public static void io_uring_free_probe(MemorySegment probe) {
        var mh$ = io_uring_free_probe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_free_probe", probe);
            }
            mh$.invokeExact(probe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_opcode_supported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_opcode_supported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_opcode_supported(const struct io_uring_probe *p, int op)
     * }
     */
    public static FunctionDescriptor io_uring_opcode_supported$descriptor() {
        return io_uring_opcode_supported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_opcode_supported(const struct io_uring_probe *p, int op)
     * }
     */
    public static MethodHandle io_uring_opcode_supported$handle() {
        return io_uring_opcode_supported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_opcode_supported(const struct io_uring_probe *p, int op)
     * }
     */
    public static MemorySegment io_uring_opcode_supported$address() {
        return io_uring_opcode_supported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_opcode_supported(const struct io_uring_probe *p, int op)
     * }
     */
    public static int io_uring_opcode_supported(MemorySegment p, int op) {
        var mh$ = io_uring_opcode_supported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_opcode_supported", p, op);
            }
            return (int)mh$.invokeExact(p, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_queue_init_mem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_queue_init_mem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_queue_init_mem(unsigned int entries, struct io_uring *ring, struct io_uring_params *p, void *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor io_uring_queue_init_mem$descriptor() {
        return io_uring_queue_init_mem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_queue_init_mem(unsigned int entries, struct io_uring *ring, struct io_uring_params *p, void *buf, size_t buf_size)
     * }
     */
    public static MethodHandle io_uring_queue_init_mem$handle() {
        return io_uring_queue_init_mem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_queue_init_mem(unsigned int entries, struct io_uring *ring, struct io_uring_params *p, void *buf, size_t buf_size)
     * }
     */
    public static MemorySegment io_uring_queue_init_mem$address() {
        return io_uring_queue_init_mem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_queue_init_mem(unsigned int entries, struct io_uring *ring, struct io_uring_params *p, void *buf, size_t buf_size)
     * }
     */
    public static int io_uring_queue_init_mem(int entries, MemorySegment ring, MemorySegment p, MemorySegment buf, long buf_size) {
        var mh$ = io_uring_queue_init_mem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_queue_init_mem", entries, ring, p, buf, buf_size);
            }
            return (int)mh$.invokeExact(entries, ring, p, buf, buf_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_queue_init_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_queue_init_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_queue_init_params(unsigned int entries, struct io_uring *ring, struct io_uring_params *p)
     * }
     */
    public static FunctionDescriptor io_uring_queue_init_params$descriptor() {
        return io_uring_queue_init_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_queue_init_params(unsigned int entries, struct io_uring *ring, struct io_uring_params *p)
     * }
     */
    public static MethodHandle io_uring_queue_init_params$handle() {
        return io_uring_queue_init_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_queue_init_params(unsigned int entries, struct io_uring *ring, struct io_uring_params *p)
     * }
     */
    public static MemorySegment io_uring_queue_init_params$address() {
        return io_uring_queue_init_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_queue_init_params(unsigned int entries, struct io_uring *ring, struct io_uring_params *p)
     * }
     */
    public static int io_uring_queue_init_params(int entries, MemorySegment ring, MemorySegment p) {
        var mh$ = io_uring_queue_init_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_queue_init_params", entries, ring, p);
            }
            return (int)mh$.invokeExact(entries, ring, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_queue_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_queue_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_queue_init(unsigned int entries, struct io_uring *ring, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_queue_init$descriptor() {
        return io_uring_queue_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_queue_init(unsigned int entries, struct io_uring *ring, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_queue_init$handle() {
        return io_uring_queue_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_queue_init(unsigned int entries, struct io_uring *ring, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_queue_init$address() {
        return io_uring_queue_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_queue_init(unsigned int entries, struct io_uring *ring, unsigned int flags)
     * }
     */
    public static int io_uring_queue_init(int entries, MemorySegment ring, int flags) {
        var mh$ = io_uring_queue_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_queue_init", entries, ring, flags);
            }
            return (int)mh$.invokeExact(entries, ring, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_queue_mmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_queue_mmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_queue_mmap(int fd, struct io_uring_params *p, struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_queue_mmap$descriptor() {
        return io_uring_queue_mmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_queue_mmap(int fd, struct io_uring_params *p, struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_queue_mmap$handle() {
        return io_uring_queue_mmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_queue_mmap(int fd, struct io_uring_params *p, struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_queue_mmap$address() {
        return io_uring_queue_mmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_queue_mmap(int fd, struct io_uring_params *p, struct io_uring *ring)
     * }
     */
    public static int io_uring_queue_mmap(int fd, MemorySegment p, MemorySegment ring) {
        var mh$ = io_uring_queue_mmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_queue_mmap", fd, p, ring);
            }
            return (int)mh$.invokeExact(fd, p, ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_ring_dontfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_ring_dontfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_ring_dontfork(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_ring_dontfork$descriptor() {
        return io_uring_ring_dontfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_ring_dontfork(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_ring_dontfork$handle() {
        return io_uring_ring_dontfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_ring_dontfork(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_ring_dontfork$address() {
        return io_uring_ring_dontfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_ring_dontfork(struct io_uring *ring)
     * }
     */
    public static int io_uring_ring_dontfork(MemorySegment ring) {
        var mh$ = io_uring_ring_dontfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_ring_dontfork", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_queue_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_queue_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void io_uring_queue_exit(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_queue_exit$descriptor() {
        return io_uring_queue_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void io_uring_queue_exit(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_queue_exit$handle() {
        return io_uring_queue_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void io_uring_queue_exit(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_queue_exit$address() {
        return io_uring_queue_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void io_uring_queue_exit(struct io_uring *ring)
     * }
     */
    public static void io_uring_queue_exit(MemorySegment ring) {
        var mh$ = io_uring_queue_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_queue_exit", ring);
            }
            mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_peek_batch_cqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_peek_batch_cqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int io_uring_peek_batch_cqe(struct io_uring *ring, struct io_uring_cqe **cqes, unsigned int count)
     * }
     */
    public static FunctionDescriptor io_uring_peek_batch_cqe$descriptor() {
        return io_uring_peek_batch_cqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int io_uring_peek_batch_cqe(struct io_uring *ring, struct io_uring_cqe **cqes, unsigned int count)
     * }
     */
    public static MethodHandle io_uring_peek_batch_cqe$handle() {
        return io_uring_peek_batch_cqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int io_uring_peek_batch_cqe(struct io_uring *ring, struct io_uring_cqe **cqes, unsigned int count)
     * }
     */
    public static MemorySegment io_uring_peek_batch_cqe$address() {
        return io_uring_peek_batch_cqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int io_uring_peek_batch_cqe(struct io_uring *ring, struct io_uring_cqe **cqes, unsigned int count)
     * }
     */
    public static int io_uring_peek_batch_cqe(MemorySegment ring, MemorySegment cqes, int count) {
        var mh$ = io_uring_peek_batch_cqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_peek_batch_cqe", ring, cqes, count);
            }
            return (int)mh$.invokeExact(ring, cqes, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_wait_cqes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_wait_cqes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_wait_cqes(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static FunctionDescriptor io_uring_wait_cqes$descriptor() {
        return io_uring_wait_cqes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_wait_cqes(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static MethodHandle io_uring_wait_cqes$handle() {
        return io_uring_wait_cqes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_wait_cqes(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static MemorySegment io_uring_wait_cqes$address() {
        return io_uring_wait_cqes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_wait_cqes(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static int io_uring_wait_cqes(MemorySegment ring, MemorySegment cqe_ptr, int wait_nr, MemorySegment ts, MemorySegment sigmask) {
        var mh$ = io_uring_wait_cqes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_wait_cqes", ring, cqe_ptr, wait_nr, ts, sigmask);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, wait_nr, ts, sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_wait_cqe_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_wait_cqe_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_wait_cqe_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, struct __kernel_timespec *ts)
     * }
     */
    public static FunctionDescriptor io_uring_wait_cqe_timeout$descriptor() {
        return io_uring_wait_cqe_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_wait_cqe_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, struct __kernel_timespec *ts)
     * }
     */
    public static MethodHandle io_uring_wait_cqe_timeout$handle() {
        return io_uring_wait_cqe_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_wait_cqe_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, struct __kernel_timespec *ts)
     * }
     */
    public static MemorySegment io_uring_wait_cqe_timeout$address() {
        return io_uring_wait_cqe_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_wait_cqe_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, struct __kernel_timespec *ts)
     * }
     */
    public static int io_uring_wait_cqe_timeout(MemorySegment ring, MemorySegment cqe_ptr, MemorySegment ts) {
        var mh$ = io_uring_wait_cqe_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_wait_cqe_timeout", ring, cqe_ptr, ts);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, ts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_submit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_submit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_submit(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_submit$descriptor() {
        return io_uring_submit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_submit(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_submit$handle() {
        return io_uring_submit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_submit(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_submit$address() {
        return io_uring_submit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_submit(struct io_uring *ring)
     * }
     */
    public static int io_uring_submit(MemorySegment ring) {
        var mh$ = io_uring_submit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_submit", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_submit_and_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_submit_and_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait(struct io_uring *ring, unsigned int wait_nr)
     * }
     */
    public static FunctionDescriptor io_uring_submit_and_wait$descriptor() {
        return io_uring_submit_and_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait(struct io_uring *ring, unsigned int wait_nr)
     * }
     */
    public static MethodHandle io_uring_submit_and_wait$handle() {
        return io_uring_submit_and_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait(struct io_uring *ring, unsigned int wait_nr)
     * }
     */
    public static MemorySegment io_uring_submit_and_wait$address() {
        return io_uring_submit_and_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_submit_and_wait(struct io_uring *ring, unsigned int wait_nr)
     * }
     */
    public static int io_uring_submit_and_wait(MemorySegment ring, int wait_nr) {
        var mh$ = io_uring_submit_and_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_submit_and_wait", ring, wait_nr);
            }
            return (int)mh$.invokeExact(ring, wait_nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_submit_and_wait_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_submit_and_wait_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static FunctionDescriptor io_uring_submit_and_wait_timeout$descriptor() {
        return io_uring_submit_and_wait_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static MethodHandle io_uring_submit_and_wait_timeout$handle() {
        return io_uring_submit_and_wait_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_submit_and_wait_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static MemorySegment io_uring_submit_and_wait_timeout$address() {
        return io_uring_submit_and_wait_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_submit_and_wait_timeout(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr, struct __kernel_timespec *ts, sigset_t *sigmask)
     * }
     */
    public static int io_uring_submit_and_wait_timeout(MemorySegment ring, MemorySegment cqe_ptr, int wait_nr, MemorySegment ts, MemorySegment sigmask) {
        var mh$ = io_uring_submit_and_wait_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_submit_and_wait_timeout", ring, cqe_ptr, wait_nr, ts, sigmask);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, wait_nr, ts, sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_buffers(struct io_uring *ring, const struct iovec *iovecs, unsigned int nr_iovecs)
     * }
     */
    public static FunctionDescriptor io_uring_register_buffers$descriptor() {
        return io_uring_register_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_buffers(struct io_uring *ring, const struct iovec *iovecs, unsigned int nr_iovecs)
     * }
     */
    public static MethodHandle io_uring_register_buffers$handle() {
        return io_uring_register_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_buffers(struct io_uring *ring, const struct iovec *iovecs, unsigned int nr_iovecs)
     * }
     */
    public static MemorySegment io_uring_register_buffers$address() {
        return io_uring_register_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_buffers(struct io_uring *ring, const struct iovec *iovecs, unsigned int nr_iovecs)
     * }
     */
    public static int io_uring_register_buffers(MemorySegment ring, MemorySegment iovecs, int nr_iovecs) {
        var mh$ = io_uring_register_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_buffers", ring, iovecs, nr_iovecs);
            }
            return (int)mh$.invokeExact(ring, iovecs, nr_iovecs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_buffers_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_buffers_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_tags(struct io_uring *ring, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_buffers_tags$descriptor() {
        return io_uring_register_buffers_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_tags(struct io_uring *ring, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_buffers_tags$handle() {
        return io_uring_register_buffers_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_tags(struct io_uring *ring, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_buffers_tags$address() {
        return io_uring_register_buffers_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_buffers_tags(struct io_uring *ring, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static int io_uring_register_buffers_tags(MemorySegment ring, MemorySegment iovecs, MemorySegment tags, int nr) {
        var mh$ = io_uring_register_buffers_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_buffers_tags", ring, iovecs, tags, nr);
            }
            return (int)mh$.invokeExact(ring, iovecs, tags, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_buffers_sparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_buffers_sparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_buffers_sparse$descriptor() {
        return io_uring_register_buffers_sparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_buffers_sparse$handle() {
        return io_uring_register_buffers_sparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_buffers_sparse$address() {
        return io_uring_register_buffers_sparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_buffers_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static int io_uring_register_buffers_sparse(MemorySegment ring, int nr) {
        var mh$ = io_uring_register_buffers_sparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_buffers_sparse", ring, nr);
            }
            return (int)mh$.invokeExact(ring, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_buffers_update_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_buffers_update_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned int off, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_buffers_update_tag$descriptor() {
        return io_uring_register_buffers_update_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned int off, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_buffers_update_tag$handle() {
        return io_uring_register_buffers_update_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned int off, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_buffers_update_tag$address() {
        return io_uring_register_buffers_update_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned int off, const struct iovec *iovecs, const __u64 *tags, unsigned int nr)
     * }
     */
    public static int io_uring_register_buffers_update_tag(MemorySegment ring, int off, MemorySegment iovecs, MemorySegment tags, int nr) {
        var mh$ = io_uring_register_buffers_update_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_buffers_update_tag", ring, off, iovecs, tags, nr);
            }
            return (int)mh$.invokeExact(ring, off, iovecs, tags, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_buffers(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_buffers$descriptor() {
        return io_uring_unregister_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_buffers(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_unregister_buffers$handle() {
        return io_uring_unregister_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_buffers(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_unregister_buffers$address() {
        return io_uring_unregister_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_buffers(struct io_uring *ring)
     * }
     */
    public static int io_uring_unregister_buffers(MemorySegment ring) {
        var mh$ = io_uring_unregister_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_buffers", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_files {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_files");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_files(struct io_uring *ring, const int *files, unsigned int nr_files)
     * }
     */
    public static FunctionDescriptor io_uring_register_files$descriptor() {
        return io_uring_register_files.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_files(struct io_uring *ring, const int *files, unsigned int nr_files)
     * }
     */
    public static MethodHandle io_uring_register_files$handle() {
        return io_uring_register_files.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_files(struct io_uring *ring, const int *files, unsigned int nr_files)
     * }
     */
    public static MemorySegment io_uring_register_files$address() {
        return io_uring_register_files.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_files(struct io_uring *ring, const int *files, unsigned int nr_files)
     * }
     */
    public static int io_uring_register_files(MemorySegment ring, MemorySegment files, int nr_files) {
        var mh$ = io_uring_register_files.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_files", ring, files, nr_files);
            }
            return (int)mh$.invokeExact(ring, files, nr_files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_files_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_files_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_files_tags(struct io_uring *ring, const int *files, const __u64 *tags, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_files_tags$descriptor() {
        return io_uring_register_files_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_files_tags(struct io_uring *ring, const int *files, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_files_tags$handle() {
        return io_uring_register_files_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_files_tags(struct io_uring *ring, const int *files, const __u64 *tags, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_files_tags$address() {
        return io_uring_register_files_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_files_tags(struct io_uring *ring, const int *files, const __u64 *tags, unsigned int nr)
     * }
     */
    public static int io_uring_register_files_tags(MemorySegment ring, MemorySegment files, MemorySegment tags, int nr) {
        var mh$ = io_uring_register_files_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_files_tags", ring, files, tags, nr);
            }
            return (int)mh$.invokeExact(ring, files, tags, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_files_sparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_files_sparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_files_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_files_sparse$descriptor() {
        return io_uring_register_files_sparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_files_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_files_sparse$handle() {
        return io_uring_register_files_sparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_files_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_files_sparse$address() {
        return io_uring_register_files_sparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_files_sparse(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static int io_uring_register_files_sparse(MemorySegment ring, int nr) {
        var mh$ = io_uring_register_files_sparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_files_sparse", ring, nr);
            }
            return (int)mh$.invokeExact(ring, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_files_update_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_files_update_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_files_update_tag(struct io_uring *ring, unsigned int off, const int *files, const __u64 *tags, unsigned int nr_files)
     * }
     */
    public static FunctionDescriptor io_uring_register_files_update_tag$descriptor() {
        return io_uring_register_files_update_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_files_update_tag(struct io_uring *ring, unsigned int off, const int *files, const __u64 *tags, unsigned int nr_files)
     * }
     */
    public static MethodHandle io_uring_register_files_update_tag$handle() {
        return io_uring_register_files_update_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_files_update_tag(struct io_uring *ring, unsigned int off, const int *files, const __u64 *tags, unsigned int nr_files)
     * }
     */
    public static MemorySegment io_uring_register_files_update_tag$address() {
        return io_uring_register_files_update_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_files_update_tag(struct io_uring *ring, unsigned int off, const int *files, const __u64 *tags, unsigned int nr_files)
     * }
     */
    public static int io_uring_register_files_update_tag(MemorySegment ring, int off, MemorySegment files, MemorySegment tags, int nr_files) {
        var mh$ = io_uring_register_files_update_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_files_update_tag", ring, off, files, tags, nr_files);
            }
            return (int)mh$.invokeExact(ring, off, files, tags, nr_files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_files {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_files");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_files(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_files$descriptor() {
        return io_uring_unregister_files.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_files(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_unregister_files$handle() {
        return io_uring_unregister_files.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_files(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_unregister_files$address() {
        return io_uring_unregister_files.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_files(struct io_uring *ring)
     * }
     */
    public static int io_uring_unregister_files(MemorySegment ring) {
        var mh$ = io_uring_unregister_files.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_files", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_files_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_files_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_files_update(struct io_uring *ring, unsigned int off, const int *files, unsigned int nr_files)
     * }
     */
    public static FunctionDescriptor io_uring_register_files_update$descriptor() {
        return io_uring_register_files_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_files_update(struct io_uring *ring, unsigned int off, const int *files, unsigned int nr_files)
     * }
     */
    public static MethodHandle io_uring_register_files_update$handle() {
        return io_uring_register_files_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_files_update(struct io_uring *ring, unsigned int off, const int *files, unsigned int nr_files)
     * }
     */
    public static MemorySegment io_uring_register_files_update$address() {
        return io_uring_register_files_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_files_update(struct io_uring *ring, unsigned int off, const int *files, unsigned int nr_files)
     * }
     */
    public static int io_uring_register_files_update(MemorySegment ring, int off, MemorySegment files, int nr_files) {
        var mh$ = io_uring_register_files_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_files_update", ring, off, files, nr_files);
            }
            return (int)mh$.invokeExact(ring, off, files, nr_files);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_eventfd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_eventfd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd(struct io_uring *ring, int fd)
     * }
     */
    public static FunctionDescriptor io_uring_register_eventfd$descriptor() {
        return io_uring_register_eventfd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd(struct io_uring *ring, int fd)
     * }
     */
    public static MethodHandle io_uring_register_eventfd$handle() {
        return io_uring_register_eventfd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd(struct io_uring *ring, int fd)
     * }
     */
    public static MemorySegment io_uring_register_eventfd$address() {
        return io_uring_register_eventfd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_eventfd(struct io_uring *ring, int fd)
     * }
     */
    public static int io_uring_register_eventfd(MemorySegment ring, int fd) {
        var mh$ = io_uring_register_eventfd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_eventfd", ring, fd);
            }
            return (int)mh$.invokeExact(ring, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_eventfd_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_eventfd_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd_async(struct io_uring *ring, int fd)
     * }
     */
    public static FunctionDescriptor io_uring_register_eventfd_async$descriptor() {
        return io_uring_register_eventfd_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd_async(struct io_uring *ring, int fd)
     * }
     */
    public static MethodHandle io_uring_register_eventfd_async$handle() {
        return io_uring_register_eventfd_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_eventfd_async(struct io_uring *ring, int fd)
     * }
     */
    public static MemorySegment io_uring_register_eventfd_async$address() {
        return io_uring_register_eventfd_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_eventfd_async(struct io_uring *ring, int fd)
     * }
     */
    public static int io_uring_register_eventfd_async(MemorySegment ring, int fd) {
        var mh$ = io_uring_register_eventfd_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_eventfd_async", ring, fd);
            }
            return (int)mh$.invokeExact(ring, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_eventfd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_eventfd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_eventfd(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_eventfd$descriptor() {
        return io_uring_unregister_eventfd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_eventfd(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_unregister_eventfd$handle() {
        return io_uring_unregister_eventfd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_eventfd(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_unregister_eventfd$address() {
        return io_uring_unregister_eventfd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_eventfd(struct io_uring *ring)
     * }
     */
    public static int io_uring_unregister_eventfd(MemorySegment ring) {
        var mh$ = io_uring_unregister_eventfd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_eventfd", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_probe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_probe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_probe(struct io_uring *ring, struct io_uring_probe *p, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_register_probe$descriptor() {
        return io_uring_register_probe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_probe(struct io_uring *ring, struct io_uring_probe *p, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_register_probe$handle() {
        return io_uring_register_probe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_probe(struct io_uring *ring, struct io_uring_probe *p, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_register_probe$address() {
        return io_uring_register_probe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_probe(struct io_uring *ring, struct io_uring_probe *p, unsigned int nr)
     * }
     */
    public static int io_uring_register_probe(MemorySegment ring, MemorySegment p, int nr) {
        var mh$ = io_uring_register_probe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_probe", ring, p, nr);
            }
            return (int)mh$.invokeExact(ring, p, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_personality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_personality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_personality(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_register_personality$descriptor() {
        return io_uring_register_personality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_personality(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_register_personality$handle() {
        return io_uring_register_personality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_personality(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_register_personality$address() {
        return io_uring_register_personality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_personality(struct io_uring *ring)
     * }
     */
    public static int io_uring_register_personality(MemorySegment ring) {
        var mh$ = io_uring_register_personality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_personality", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_personality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_personality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_personality(struct io_uring *ring, int id)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_personality$descriptor() {
        return io_uring_unregister_personality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_personality(struct io_uring *ring, int id)
     * }
     */
    public static MethodHandle io_uring_unregister_personality$handle() {
        return io_uring_unregister_personality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_personality(struct io_uring *ring, int id)
     * }
     */
    public static MemorySegment io_uring_unregister_personality$address() {
        return io_uring_unregister_personality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_personality(struct io_uring *ring, int id)
     * }
     */
    public static int io_uring_unregister_personality(MemorySegment ring, int id) {
        var mh$ = io_uring_unregister_personality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_personality", ring, id);
            }
            return (int)mh$.invokeExact(ring, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_restrictions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_restrictions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_restrictions(struct io_uring *ring, struct io_uring_restriction *res, unsigned int nr_res)
     * }
     */
    public static FunctionDescriptor io_uring_register_restrictions$descriptor() {
        return io_uring_register_restrictions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_restrictions(struct io_uring *ring, struct io_uring_restriction *res, unsigned int nr_res)
     * }
     */
    public static MethodHandle io_uring_register_restrictions$handle() {
        return io_uring_register_restrictions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_restrictions(struct io_uring *ring, struct io_uring_restriction *res, unsigned int nr_res)
     * }
     */
    public static MemorySegment io_uring_register_restrictions$address() {
        return io_uring_register_restrictions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_restrictions(struct io_uring *ring, struct io_uring_restriction *res, unsigned int nr_res)
     * }
     */
    public static int io_uring_register_restrictions(MemorySegment ring, MemorySegment res, int nr_res) {
        var mh$ = io_uring_register_restrictions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_restrictions", ring, res, nr_res);
            }
            return (int)mh$.invokeExact(ring, res, nr_res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_enable_rings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_enable_rings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_enable_rings(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_enable_rings$descriptor() {
        return io_uring_enable_rings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_enable_rings(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_enable_rings$handle() {
        return io_uring_enable_rings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_enable_rings(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_enable_rings$address() {
        return io_uring_enable_rings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_enable_rings(struct io_uring *ring)
     * }
     */
    public static int io_uring_enable_rings(MemorySegment ring) {
        var mh$ = io_uring_enable_rings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_enable_rings", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_sqring_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_sqring_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor __io_uring_sqring_wait$descriptor() {
        return __io_uring_sqring_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static MethodHandle __io_uring_sqring_wait$handle() {
        return __io_uring_sqring_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static MemorySegment __io_uring_sqring_wait$address() {
        return __io_uring_sqring_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static int __io_uring_sqring_wait(MemorySegment ring) {
        var mh$ = __io_uring_sqring_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_sqring_wait", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_iowq_aff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_iowq_aff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_aff(struct io_uring *ring, size_t cpusz, const cpu_set_t *mask)
     * }
     */
    public static FunctionDescriptor io_uring_register_iowq_aff$descriptor() {
        return io_uring_register_iowq_aff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_aff(struct io_uring *ring, size_t cpusz, const cpu_set_t *mask)
     * }
     */
    public static MethodHandle io_uring_register_iowq_aff$handle() {
        return io_uring_register_iowq_aff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_aff(struct io_uring *ring, size_t cpusz, const cpu_set_t *mask)
     * }
     */
    public static MemorySegment io_uring_register_iowq_aff$address() {
        return io_uring_register_iowq_aff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_iowq_aff(struct io_uring *ring, size_t cpusz, const cpu_set_t *mask)
     * }
     */
    public static int io_uring_register_iowq_aff(MemorySegment ring, long cpusz, MemorySegment mask) {
        var mh$ = io_uring_register_iowq_aff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_iowq_aff", ring, cpusz, mask);
            }
            return (int)mh$.invokeExact(ring, cpusz, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_iowq_aff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_iowq_aff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_iowq_aff(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_iowq_aff$descriptor() {
        return io_uring_unregister_iowq_aff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_iowq_aff(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_unregister_iowq_aff$handle() {
        return io_uring_unregister_iowq_aff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_iowq_aff(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_unregister_iowq_aff$address() {
        return io_uring_unregister_iowq_aff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_iowq_aff(struct io_uring *ring)
     * }
     */
    public static int io_uring_unregister_iowq_aff(MemorySegment ring) {
        var mh$ = io_uring_unregister_iowq_aff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_iowq_aff", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_iowq_max_workers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_iowq_max_workers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_max_workers(struct io_uring *ring, unsigned int *values)
     * }
     */
    public static FunctionDescriptor io_uring_register_iowq_max_workers$descriptor() {
        return io_uring_register_iowq_max_workers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_max_workers(struct io_uring *ring, unsigned int *values)
     * }
     */
    public static MethodHandle io_uring_register_iowq_max_workers$handle() {
        return io_uring_register_iowq_max_workers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_iowq_max_workers(struct io_uring *ring, unsigned int *values)
     * }
     */
    public static MemorySegment io_uring_register_iowq_max_workers$address() {
        return io_uring_register_iowq_max_workers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_iowq_max_workers(struct io_uring *ring, unsigned int *values)
     * }
     */
    public static int io_uring_register_iowq_max_workers(MemorySegment ring, MemorySegment values) {
        var mh$ = io_uring_register_iowq_max_workers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_iowq_max_workers", ring, values);
            }
            return (int)mh$.invokeExact(ring, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_ring_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_ring_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_ring_fd(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_register_ring_fd$descriptor() {
        return io_uring_register_ring_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_ring_fd(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_register_ring_fd$handle() {
        return io_uring_register_ring_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_ring_fd(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_register_ring_fd$address() {
        return io_uring_register_ring_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_ring_fd(struct io_uring *ring)
     * }
     */
    public static int io_uring_register_ring_fd(MemorySegment ring) {
        var mh$ = io_uring_register_ring_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_ring_fd", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_ring_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_ring_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_ring_fd(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_ring_fd$descriptor() {
        return io_uring_unregister_ring_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_ring_fd(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_unregister_ring_fd$handle() {
        return io_uring_unregister_ring_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_ring_fd(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_unregister_ring_fd$address() {
        return io_uring_unregister_ring_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_ring_fd(struct io_uring *ring)
     * }
     */
    public static int io_uring_unregister_ring_fd(MemorySegment ring) {
        var mh$ = io_uring_unregister_ring_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_ring_fd", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_close_ring_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_close_ring_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_close_ring_fd(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_close_ring_fd$descriptor() {
        return io_uring_close_ring_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_close_ring_fd(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_close_ring_fd$handle() {
        return io_uring_close_ring_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_close_ring_fd(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_close_ring_fd$address() {
        return io_uring_close_ring_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_close_ring_fd(struct io_uring *ring)
     * }
     */
    public static int io_uring_close_ring_fd(MemorySegment ring) {
        var mh$ = io_uring_close_ring_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_close_ring_fd", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_buf_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_buf_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_buf_ring(struct io_uring *ring, struct io_uring_buf_reg *reg, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_register_buf_ring$descriptor() {
        return io_uring_register_buf_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_buf_ring(struct io_uring *ring, struct io_uring_buf_reg *reg, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_register_buf_ring$handle() {
        return io_uring_register_buf_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_buf_ring(struct io_uring *ring, struct io_uring_buf_reg *reg, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_register_buf_ring$address() {
        return io_uring_register_buf_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_buf_ring(struct io_uring *ring, struct io_uring_buf_reg *reg, unsigned int flags)
     * }
     */
    public static int io_uring_register_buf_ring(MemorySegment ring, MemorySegment reg, int flags) {
        var mh$ = io_uring_register_buf_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_buf_ring", ring, reg, flags);
            }
            return (int)mh$.invokeExact(ring, reg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_buf_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_buf_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_buf_ring(struct io_uring *ring, int bgid)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_buf_ring$descriptor() {
        return io_uring_unregister_buf_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_buf_ring(struct io_uring *ring, int bgid)
     * }
     */
    public static MethodHandle io_uring_unregister_buf_ring$handle() {
        return io_uring_unregister_buf_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_buf_ring(struct io_uring *ring, int bgid)
     * }
     */
    public static MemorySegment io_uring_unregister_buf_ring$address() {
        return io_uring_unregister_buf_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_buf_ring(struct io_uring *ring, int bgid)
     * }
     */
    public static int io_uring_unregister_buf_ring(MemorySegment ring, int bgid) {
        var mh$ = io_uring_unregister_buf_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_buf_ring", ring, bgid);
            }
            return (int)mh$.invokeExact(ring, bgid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_buf_ring_head(struct io_uring *ring, int buf_group, uint16_t *head)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_head$descriptor() {
        return io_uring_buf_ring_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_buf_ring_head(struct io_uring *ring, int buf_group, uint16_t *head)
     * }
     */
    public static MethodHandle io_uring_buf_ring_head$handle() {
        return io_uring_buf_ring_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_buf_ring_head(struct io_uring *ring, int buf_group, uint16_t *head)
     * }
     */
    public static MemorySegment io_uring_buf_ring_head$address() {
        return io_uring_buf_ring_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_buf_ring_head(struct io_uring *ring, int buf_group, uint16_t *head)
     * }
     */
    public static int io_uring_buf_ring_head(MemorySegment ring, int buf_group, MemorySegment head) {
        var mh$ = io_uring_buf_ring_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_head", ring, buf_group, head);
            }
            return (int)mh$.invokeExact(ring, buf_group, head);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_sync_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_sync_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_sync_cancel(struct io_uring *ring, struct io_uring_sync_cancel_reg *reg)
     * }
     */
    public static FunctionDescriptor io_uring_register_sync_cancel$descriptor() {
        return io_uring_register_sync_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_sync_cancel(struct io_uring *ring, struct io_uring_sync_cancel_reg *reg)
     * }
     */
    public static MethodHandle io_uring_register_sync_cancel$handle() {
        return io_uring_register_sync_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_sync_cancel(struct io_uring *ring, struct io_uring_sync_cancel_reg *reg)
     * }
     */
    public static MemorySegment io_uring_register_sync_cancel$address() {
        return io_uring_register_sync_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_sync_cancel(struct io_uring *ring, struct io_uring_sync_cancel_reg *reg)
     * }
     */
    public static int io_uring_register_sync_cancel(MemorySegment ring, MemorySegment reg) {
        var mh$ = io_uring_register_sync_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_sync_cancel", ring, reg);
            }
            return (int)mh$.invokeExact(ring, reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_file_alloc_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_file_alloc_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_file_alloc_range(struct io_uring *ring, unsigned int off, unsigned int len)
     * }
     */
    public static FunctionDescriptor io_uring_register_file_alloc_range$descriptor() {
        return io_uring_register_file_alloc_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_file_alloc_range(struct io_uring *ring, unsigned int off, unsigned int len)
     * }
     */
    public static MethodHandle io_uring_register_file_alloc_range$handle() {
        return io_uring_register_file_alloc_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_file_alloc_range(struct io_uring *ring, unsigned int off, unsigned int len)
     * }
     */
    public static MemorySegment io_uring_register_file_alloc_range$address() {
        return io_uring_register_file_alloc_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_file_alloc_range(struct io_uring *ring, unsigned int off, unsigned int len)
     * }
     */
    public static int io_uring_register_file_alloc_range(MemorySegment ring, int off, int len) {
        var mh$ = io_uring_register_file_alloc_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_file_alloc_range", ring, off, len);
            }
            return (int)mh$.invokeExact(ring, off, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_napi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_napi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static FunctionDescriptor io_uring_register_napi$descriptor() {
        return io_uring_register_napi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static MethodHandle io_uring_register_napi$handle() {
        return io_uring_register_napi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static MemorySegment io_uring_register_napi$address() {
        return io_uring_register_napi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static int io_uring_register_napi(MemorySegment ring, MemorySegment napi) {
        var mh$ = io_uring_register_napi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_napi", ring, napi);
            }
            return (int)mh$.invokeExact(ring, napi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_unregister_napi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_unregister_napi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_unregister_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static FunctionDescriptor io_uring_unregister_napi$descriptor() {
        return io_uring_unregister_napi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_unregister_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static MethodHandle io_uring_unregister_napi$handle() {
        return io_uring_unregister_napi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_unregister_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static MemorySegment io_uring_unregister_napi$address() {
        return io_uring_unregister_napi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_unregister_napi(struct io_uring *ring, struct io_uring_napi *napi)
     * }
     */
    public static int io_uring_unregister_napi(MemorySegment ring, MemorySegment napi) {
        var mh$ = io_uring_unregister_napi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_unregister_napi", ring, napi);
            }
            return (int)mh$.invokeExact(ring, napi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register_clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register_clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register_clock(struct io_uring *ring, struct io_uring_clock_register *arg)
     * }
     */
    public static FunctionDescriptor io_uring_register_clock$descriptor() {
        return io_uring_register_clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register_clock(struct io_uring *ring, struct io_uring_clock_register *arg)
     * }
     */
    public static MethodHandle io_uring_register_clock$handle() {
        return io_uring_register_clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register_clock(struct io_uring *ring, struct io_uring_clock_register *arg)
     * }
     */
    public static MemorySegment io_uring_register_clock$address() {
        return io_uring_register_clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register_clock(struct io_uring *ring, struct io_uring_clock_register *arg)
     * }
     */
    public static int io_uring_register_clock(MemorySegment ring, MemorySegment arg) {
        var mh$ = io_uring_register_clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register_clock", ring, arg);
            }
            return (int)mh$.invokeExact(ring, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_get_events {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_get_events");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_get_events(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_get_events$descriptor() {
        return io_uring_get_events.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_get_events(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_get_events$handle() {
        return io_uring_get_events.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_get_events(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_get_events$address() {
        return io_uring_get_events.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_get_events(struct io_uring *ring)
     * }
     */
    public static int io_uring_get_events(MemorySegment ring) {
        var mh$ = io_uring_get_events.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_get_events", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_submit_and_get_events {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_submit_and_get_events");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_submit_and_get_events(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_submit_and_get_events$descriptor() {
        return io_uring_submit_and_get_events.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_submit_and_get_events(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_submit_and_get_events$handle() {
        return io_uring_submit_and_get_events.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_submit_and_get_events(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_submit_and_get_events$address() {
        return io_uring_submit_and_get_events.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_submit_and_get_events(struct io_uring *ring)
     * }
     */
    public static int io_uring_submit_and_get_events(MemorySegment ring) {
        var mh$ = io_uring_submit_and_get_events.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_submit_and_get_events", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig)
     * }
     */
    public static FunctionDescriptor io_uring_enter$descriptor() {
        return io_uring_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig)
     * }
     */
    public static MethodHandle io_uring_enter$handle() {
        return io_uring_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig)
     * }
     */
    public static MemorySegment io_uring_enter$address() {
        return io_uring_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig)
     * }
     */
    public static int io_uring_enter(int fd, int to_submit, int min_complete, int flags, MemorySegment sig) {
        var mh$ = io_uring_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_enter", fd, to_submit, min_complete, flags, sig);
            }
            return (int)mh$.invokeExact(fd, to_submit, min_complete, flags, sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_enter2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_enter2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_enter2(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig, size_t sz)
     * }
     */
    public static FunctionDescriptor io_uring_enter2$descriptor() {
        return io_uring_enter2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_enter2(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig, size_t sz)
     * }
     */
    public static MethodHandle io_uring_enter2$handle() {
        return io_uring_enter2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_enter2(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig, size_t sz)
     * }
     */
    public static MemorySegment io_uring_enter2$address() {
        return io_uring_enter2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_enter2(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig, size_t sz)
     * }
     */
    public static int io_uring_enter2(int fd, int to_submit, int min_complete, int flags, MemorySegment sig, long sz) {
        var mh$ = io_uring_enter2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_enter2", fd, to_submit, min_complete, flags, sig, sz);
            }
            return (int)mh$.invokeExact(fd, to_submit, min_complete, flags, sig, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_setup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_setup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_setup(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static FunctionDescriptor io_uring_setup$descriptor() {
        return io_uring_setup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_setup(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static MethodHandle io_uring_setup$handle() {
        return io_uring_setup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_setup(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static MemorySegment io_uring_setup$address() {
        return io_uring_setup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_setup(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static int io_uring_setup(int entries, MemorySegment p) {
        var mh$ = io_uring_setup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_setup", entries, p);
            }
            return (int)mh$.invokeExact(entries, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_register(unsigned int fd, unsigned int opcode, const void *arg, unsigned int nr_args)
     * }
     */
    public static FunctionDescriptor io_uring_register$descriptor() {
        return io_uring_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_register(unsigned int fd, unsigned int opcode, const void *arg, unsigned int nr_args)
     * }
     */
    public static MethodHandle io_uring_register$handle() {
        return io_uring_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_register(unsigned int fd, unsigned int opcode, const void *arg, unsigned int nr_args)
     * }
     */
    public static MemorySegment io_uring_register$address() {
        return io_uring_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_register(unsigned int fd, unsigned int opcode, const void *arg, unsigned int nr_args)
     * }
     */
    public static int io_uring_register(int fd, int opcode, MemorySegment arg, int nr_args) {
        var mh$ = io_uring_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_register", fd, opcode, arg, nr_args);
            }
            return (int)mh$.invokeExact(fd, opcode, arg, nr_args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_setup_buf_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_setup_buf_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct io_uring_buf_ring *io_uring_setup_buf_ring(struct io_uring *ring, unsigned int nentries, int bgid, unsigned int flags, int *ret)
     * }
     */
    public static FunctionDescriptor io_uring_setup_buf_ring$descriptor() {
        return io_uring_setup_buf_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct io_uring_buf_ring *io_uring_setup_buf_ring(struct io_uring *ring, unsigned int nentries, int bgid, unsigned int flags, int *ret)
     * }
     */
    public static MethodHandle io_uring_setup_buf_ring$handle() {
        return io_uring_setup_buf_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct io_uring_buf_ring *io_uring_setup_buf_ring(struct io_uring *ring, unsigned int nentries, int bgid, unsigned int flags, int *ret)
     * }
     */
    public static MemorySegment io_uring_setup_buf_ring$address() {
        return io_uring_setup_buf_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct io_uring_buf_ring *io_uring_setup_buf_ring(struct io_uring *ring, unsigned int nentries, int bgid, unsigned int flags, int *ret)
     * }
     */
    public static MemorySegment io_uring_setup_buf_ring(MemorySegment ring, int nentries, int bgid, int flags, MemorySegment ret) {
        var mh$ = io_uring_setup_buf_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_setup_buf_ring", ring, nentries, bgid, flags, ret);
            }
            return (MemorySegment)mh$.invokeExact(ring, nentries, bgid, flags, ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_free_buf_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_free_buf_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_free_buf_ring(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned int nentries, int bgid)
     * }
     */
    public static FunctionDescriptor io_uring_free_buf_ring$descriptor() {
        return io_uring_free_buf_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_free_buf_ring(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned int nentries, int bgid)
     * }
     */
    public static MethodHandle io_uring_free_buf_ring$handle() {
        return io_uring_free_buf_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_free_buf_ring(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned int nentries, int bgid)
     * }
     */
    public static MemorySegment io_uring_free_buf_ring$address() {
        return io_uring_free_buf_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_free_buf_ring(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned int nentries, int bgid)
     * }
     */
    public static int io_uring_free_buf_ring(MemorySegment ring, MemorySegment br, int nentries, int bgid) {
        var mh$ = io_uring_free_buf_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_free_buf_ring", ring, br, nentries, bgid);
            }
            return (int)mh$.invokeExact(ring, br, nentries, bgid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_get_cqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_get_cqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __io_uring_get_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int submit, unsigned int wait_nr, sigset_t *sigmask)
     * }
     */
    public static FunctionDescriptor __io_uring_get_cqe$descriptor() {
        return __io_uring_get_cqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __io_uring_get_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int submit, unsigned int wait_nr, sigset_t *sigmask)
     * }
     */
    public static MethodHandle __io_uring_get_cqe$handle() {
        return __io_uring_get_cqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __io_uring_get_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int submit, unsigned int wait_nr, sigset_t *sigmask)
     * }
     */
    public static MemorySegment __io_uring_get_cqe$address() {
        return __io_uring_get_cqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __io_uring_get_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int submit, unsigned int wait_nr, sigset_t *sigmask)
     * }
     */
    public static int __io_uring_get_cqe(MemorySegment ring, MemorySegment cqe_ptr, int submit, int wait_nr, MemorySegment sigmask) {
        var mh$ = __io_uring_get_cqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_get_cqe", ring, cqe_ptr, submit, wait_nr, sigmask);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, submit, wait_nr, sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cq_advance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cq_advance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_cq_advance(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static FunctionDescriptor io_uring_cq_advance$descriptor() {
        return io_uring_cq_advance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_cq_advance(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MethodHandle io_uring_cq_advance$handle() {
        return io_uring_cq_advance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_cq_advance(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static MemorySegment io_uring_cq_advance$address() {
        return io_uring_cq_advance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_cq_advance(struct io_uring *ring, unsigned int nr)
     * }
     */
    public static void io_uring_cq_advance(MemorySegment ring, int nr) {
        var mh$ = io_uring_cq_advance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cq_advance", ring, nr);
            }
            mh$.invokeExact(ring, nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cqe_seen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cqe_seen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe)
     * }
     */
    public static FunctionDescriptor io_uring_cqe_seen$descriptor() {
        return io_uring_cqe_seen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe)
     * }
     */
    public static MethodHandle io_uring_cqe_seen$handle() {
        return io_uring_cqe_seen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe)
     * }
     */
    public static MemorySegment io_uring_cqe_seen$address() {
        return io_uring_cqe_seen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_cqe_seen(struct io_uring *ring, struct io_uring_cqe *cqe)
     * }
     */
    public static void io_uring_cqe_seen(MemorySegment ring, MemorySegment cqe) {
        var mh$ = io_uring_cqe_seen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cqe_seen", ring, cqe);
            }
            mh$.invokeExact(ring, cqe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sqe_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sqe_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    private static class io_uring_sqe_set_data_long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                liburingtest.C_POINTER,
                liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sqe_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data)
     * }
     */
    public static FunctionDescriptor io_uring_sqe_set_data$descriptor() {
        return io_uring_sqe_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data)
     * }
     */
    public static MethodHandle io_uring_sqe_set_data$handle() {
        return io_uring_sqe_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data)
     * }
     */
    public static MemorySegment io_uring_sqe_set_data$address() {
        return io_uring_sqe_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data(struct io_uring_sqe *sqe, void *data)
     * }
     */
    public static void io_uring_sqe_set_data(MemorySegment sqe, MemorySegment data) {
        var mh$ = io_uring_sqe_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sqe_set_data", sqe, data);
            }
            mh$.invokeExact(sqe, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static void io_uring_sqe_set_data_long(MemorySegment sqe, Long data) {
        var mh$ = io_uring_sqe_set_data_long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sqe_set_data", sqe, data);
            }
            mh$.invoke(sqe, data);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cqe_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cqe_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *io_uring_cqe_get_data(const struct io_uring_cqe *cqe)
     * }
     */
    public static FunctionDescriptor io_uring_cqe_get_data$descriptor() {
        return io_uring_cqe_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *io_uring_cqe_get_data(const struct io_uring_cqe *cqe)
     * }
     */
    public static MethodHandle io_uring_cqe_get_data$handle() {
        return io_uring_cqe_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *io_uring_cqe_get_data(const struct io_uring_cqe *cqe)
     * }
     */
    public static MemorySegment io_uring_cqe_get_data$address() {
        return io_uring_cqe_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *io_uring_cqe_get_data(const struct io_uring_cqe *cqe)
     * }
     */
    public static MemorySegment io_uring_cqe_get_data(MemorySegment cqe) {
        var mh$ = io_uring_cqe_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cqe_get_data", cqe);
            }
            return (MemorySegment)mh$.invokeExact(cqe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sqe_set_data64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sqe_set_data64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data64(struct io_uring_sqe *sqe, __u64 data)
     * }
     */
    public static FunctionDescriptor io_uring_sqe_set_data64$descriptor() {
        return io_uring_sqe_set_data64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data64(struct io_uring_sqe *sqe, __u64 data)
     * }
     */
    public static MethodHandle io_uring_sqe_set_data64$handle() {
        return io_uring_sqe_set_data64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data64(struct io_uring_sqe *sqe, __u64 data)
     * }
     */
    public static MemorySegment io_uring_sqe_set_data64$address() {
        return io_uring_sqe_set_data64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_data64(struct io_uring_sqe *sqe, __u64 data)
     * }
     */
    public static void io_uring_sqe_set_data64(MemorySegment sqe, long data) {
        var mh$ = io_uring_sqe_set_data64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sqe_set_data64", sqe, data);
            }
            mh$.invokeExact(sqe, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cqe_get_data64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG_LONG,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cqe_get_data64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __u64 io_uring_cqe_get_data64(const struct io_uring_cqe *cqe)
     * }
     */
    public static FunctionDescriptor io_uring_cqe_get_data64$descriptor() {
        return io_uring_cqe_get_data64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __u64 io_uring_cqe_get_data64(const struct io_uring_cqe *cqe)
     * }
     */
    public static MethodHandle io_uring_cqe_get_data64$handle() {
        return io_uring_cqe_get_data64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __u64 io_uring_cqe_get_data64(const struct io_uring_cqe *cqe)
     * }
     */
    public static MemorySegment io_uring_cqe_get_data64$address() {
        return io_uring_cqe_get_data64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __u64 io_uring_cqe_get_data64(const struct io_uring_cqe *cqe)
     * }
     */
    public static long io_uring_cqe_get_data64(MemorySegment cqe) {
        var mh$ = io_uring_cqe_get_data64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cqe_get_data64", cqe);
            }
            return (long)mh$.invokeExact(cqe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sqe_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sqe_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_flags(struct io_uring_sqe *sqe, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_sqe_set_flags$descriptor() {
        return io_uring_sqe_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_flags(struct io_uring_sqe *sqe, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_sqe_set_flags$handle() {
        return io_uring_sqe_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_flags(struct io_uring_sqe *sqe, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_sqe_set_flags$address() {
        return io_uring_sqe_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_sqe_set_flags(struct io_uring_sqe *sqe, unsigned int flags)
     * }
     */
    public static void io_uring_sqe_set_flags(MemorySegment sqe, int flags) {
        var mh$ = io_uring_sqe_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sqe_set_flags", sqe, flags);
            }
            mh$.invokeExact(sqe, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_set_target_fixed_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_set_target_fixed_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __io_uring_set_target_fixed_file(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static FunctionDescriptor __io_uring_set_target_fixed_file$descriptor() {
        return __io_uring_set_target_fixed_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __io_uring_set_target_fixed_file(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static MethodHandle __io_uring_set_target_fixed_file$handle() {
        return __io_uring_set_target_fixed_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __io_uring_set_target_fixed_file(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static MemorySegment __io_uring_set_target_fixed_file$address() {
        return __io_uring_set_target_fixed_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __io_uring_set_target_fixed_file(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static void __io_uring_set_target_fixed_file(MemorySegment sqe, int file_index) {
        var mh$ = __io_uring_set_target_fixed_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_set_target_fixed_file", sqe, file_index);
            }
            mh$.invokeExact(sqe, file_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_initialize_sqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_initialize_sqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_initialize_sqe(struct io_uring_sqe *sqe)
     * }
     */
    public static FunctionDescriptor io_uring_initialize_sqe$descriptor() {
        return io_uring_initialize_sqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_initialize_sqe(struct io_uring_sqe *sqe)
     * }
     */
    public static MethodHandle io_uring_initialize_sqe$handle() {
        return io_uring_initialize_sqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_initialize_sqe(struct io_uring_sqe *sqe)
     * }
     */
    public static MemorySegment io_uring_initialize_sqe$address() {
        return io_uring_initialize_sqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_initialize_sqe(struct io_uring_sqe *sqe)
     * }
     */
    public static void io_uring_initialize_sqe(MemorySegment sqe) {
        var mh$ = io_uring_initialize_sqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_initialize_sqe", sqe);
            }
            mh$.invokeExact(sqe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_rw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_rw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rw(int op, struct io_uring_sqe *sqe, int fd, const void *addr, unsigned int len, __u64 offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_rw$descriptor() {
        return io_uring_prep_rw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rw(int op, struct io_uring_sqe *sqe, int fd, const void *addr, unsigned int len, __u64 offset)
     * }
     */
    public static MethodHandle io_uring_prep_rw$handle() {
        return io_uring_prep_rw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rw(int op, struct io_uring_sqe *sqe, int fd, const void *addr, unsigned int len, __u64 offset)
     * }
     */
    public static MemorySegment io_uring_prep_rw$address() {
        return io_uring_prep_rw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_rw(int op, struct io_uring_sqe *sqe, int fd, const void *addr, unsigned int len, __u64 offset)
     * }
     */
    public static void io_uring_prep_rw(int op, MemorySegment sqe, int fd, MemorySegment addr, int len, long offset) {
        var mh$ = io_uring_prep_rw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_rw", op, sqe, fd, addr, len, offset);
            }
            mh$.invokeExact(op, sqe, fd, addr, len, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_splice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_splice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_splice(struct io_uring_sqe *sqe, int fd_in, int64_t off_in, int fd_out, int64_t off_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_splice$descriptor() {
        return io_uring_prep_splice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_splice(struct io_uring_sqe *sqe, int fd_in, int64_t off_in, int fd_out, int64_t off_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static MethodHandle io_uring_prep_splice$handle() {
        return io_uring_prep_splice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_splice(struct io_uring_sqe *sqe, int fd_in, int64_t off_in, int fd_out, int64_t off_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static MemorySegment io_uring_prep_splice$address() {
        return io_uring_prep_splice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_splice(struct io_uring_sqe *sqe, int fd_in, int64_t off_in, int fd_out, int64_t off_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static void io_uring_prep_splice(MemorySegment sqe, int fd_in, long off_in, int fd_out, long off_out, int nbytes, int splice_flags) {
        var mh$ = io_uring_prep_splice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_splice", sqe, fd_in, off_in, fd_out, off_out, nbytes, splice_flags);
            }
            mh$.invokeExact(sqe, fd_in, off_in, fd_out, off_out, nbytes, splice_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_tee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_tee");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_tee(struct io_uring_sqe *sqe, int fd_in, int fd_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_tee$descriptor() {
        return io_uring_prep_tee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_tee(struct io_uring_sqe *sqe, int fd_in, int fd_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static MethodHandle io_uring_prep_tee$handle() {
        return io_uring_prep_tee.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_tee(struct io_uring_sqe *sqe, int fd_in, int fd_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static MemorySegment io_uring_prep_tee$address() {
        return io_uring_prep_tee.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_tee(struct io_uring_sqe *sqe, int fd_in, int fd_out, unsigned int nbytes, unsigned int splice_flags)
     * }
     */
    public static void io_uring_prep_tee(MemorySegment sqe, int fd_in, int fd_out, int nbytes, int splice_flags) {
        var mh$ = io_uring_prep_tee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_tee", sqe, fd_in, fd_out, nbytes, splice_flags);
            }
            mh$.invokeExact(sqe, fd_in, fd_out, nbytes, splice_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_readv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_readv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_readv$descriptor() {
        return io_uring_prep_readv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static MethodHandle io_uring_prep_readv$handle() {
        return io_uring_prep_readv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static MemorySegment io_uring_prep_readv$address() {
        return io_uring_prep_readv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_readv(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static void io_uring_prep_readv(MemorySegment sqe, int fd, MemorySegment iovecs, int nr_vecs, long offset) {
        var mh$ = io_uring_prep_readv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_readv", sqe, fd, iovecs, nr_vecs, offset);
            }
            mh$.invokeExact(sqe, fd, iovecs, nr_vecs, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_readv2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_readv2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_readv2$descriptor() {
        return io_uring_prep_readv2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_readv2$handle() {
        return io_uring_prep_readv2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_readv2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_readv2$address() {
        return io_uring_prep_readv2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_readv2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static void io_uring_prep_readv2(MemorySegment sqe, int fd, MemorySegment iovecs, int nr_vecs, long offset, int flags) {
        var mh$ = io_uring_prep_readv2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_readv2", sqe, fd, iovecs, nr_vecs, offset, flags);
            }
            mh$.invokeExact(sqe, fd, iovecs, nr_vecs, offset, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_read_fixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_read_fixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_fixed(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_read_fixed$descriptor() {
        return io_uring_prep_read_fixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_fixed(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static MethodHandle io_uring_prep_read_fixed$handle() {
        return io_uring_prep_read_fixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_fixed(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static MemorySegment io_uring_prep_read_fixed$address() {
        return io_uring_prep_read_fixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_read_fixed(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static void io_uring_prep_read_fixed(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset, int buf_index) {
        var mh$ = io_uring_prep_read_fixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_read_fixed", sqe, fd, buf, nbytes, offset, buf_index);
            }
            mh$.invokeExact(sqe, fd, buf, nbytes, offset, buf_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_writev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_writev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_writev$descriptor() {
        return io_uring_prep_writev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static MethodHandle io_uring_prep_writev$handle() {
        return io_uring_prep_writev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static MemorySegment io_uring_prep_writev$address() {
        return io_uring_prep_writev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_writev(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset)
     * }
     */
    public static void io_uring_prep_writev(MemorySegment sqe, int fd, MemorySegment iovecs, int nr_vecs, long offset) {
        var mh$ = io_uring_prep_writev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_writev", sqe, fd, iovecs, nr_vecs, offset);
            }
            mh$.invokeExact(sqe, fd, iovecs, nr_vecs, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_writev2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_writev2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_writev2$descriptor() {
        return io_uring_prep_writev2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_writev2$handle() {
        return io_uring_prep_writev2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_writev2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_writev2$address() {
        return io_uring_prep_writev2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_writev2(struct io_uring_sqe *sqe, int fd, const struct iovec *iovecs, unsigned int nr_vecs, __u64 offset, int flags)
     * }
     */
    public static void io_uring_prep_writev2(MemorySegment sqe, int fd, MemorySegment iovecs, int nr_vecs, long offset, int flags) {
        var mh$ = io_uring_prep_writev2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_writev2", sqe, fd, iovecs, nr_vecs, offset, flags);
            }
            mh$.invokeExact(sqe, fd, iovecs, nr_vecs, offset, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_write_fixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_write_fixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write_fixed(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_write_fixed$descriptor() {
        return io_uring_prep_write_fixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write_fixed(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static MethodHandle io_uring_prep_write_fixed$handle() {
        return io_uring_prep_write_fixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write_fixed(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static MemorySegment io_uring_prep_write_fixed$address() {
        return io_uring_prep_write_fixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_write_fixed(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset, int buf_index)
     * }
     */
    public static void io_uring_prep_write_fixed(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset, int buf_index) {
        var mh$ = io_uring_prep_write_fixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_write_fixed", sqe, fd, buf, nbytes, offset, buf_index);
            }
            mh$.invokeExact(sqe, fd, buf, nbytes, offset, buf_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_recvmsg$descriptor() {
        return io_uring_prep_recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_recvmsg$handle() {
        return io_uring_prep_recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_recvmsg$address() {
        return io_uring_prep_recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static void io_uring_prep_recvmsg(MemorySegment sqe, int fd, MemorySegment msg, int flags) {
        var mh$ = io_uring_prep_recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_recvmsg", sqe, fd, msg, flags);
            }
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_recvmsg_multishot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_recvmsg_multishot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg_multishot(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_recvmsg_multishot$descriptor() {
        return io_uring_prep_recvmsg_multishot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg_multishot(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_recvmsg_multishot$handle() {
        return io_uring_prep_recvmsg_multishot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg_multishot(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_recvmsg_multishot$address() {
        return io_uring_prep_recvmsg_multishot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_recvmsg_multishot(struct io_uring_sqe *sqe, int fd, struct msghdr *msg, unsigned int flags)
     * }
     */
    public static void io_uring_prep_recvmsg_multishot(MemorySegment sqe, int fd, MemorySegment msg, int flags) {
        var mh$ = io_uring_prep_recvmsg_multishot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_recvmsg_multishot", sqe, fd, msg, flags);
            }
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_sendmsg$descriptor() {
        return io_uring_prep_sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_sendmsg$handle() {
        return io_uring_prep_sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_sendmsg$address() {
        return io_uring_prep_sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static void io_uring_prep_sendmsg(MemorySegment sqe, int fd, MemorySegment msg, int flags) {
        var mh$ = io_uring_prep_sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_sendmsg", sqe, fd, msg, flags);
            }
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_prep_poll_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_prep_poll_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int __io_uring_prep_poll_mask(unsigned int poll_mask)
     * }
     */
    public static FunctionDescriptor __io_uring_prep_poll_mask$descriptor() {
        return __io_uring_prep_poll_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int __io_uring_prep_poll_mask(unsigned int poll_mask)
     * }
     */
    public static MethodHandle __io_uring_prep_poll_mask$handle() {
        return __io_uring_prep_poll_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int __io_uring_prep_poll_mask(unsigned int poll_mask)
     * }
     */
    public static MemorySegment __io_uring_prep_poll_mask$address() {
        return __io_uring_prep_poll_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int __io_uring_prep_poll_mask(unsigned int poll_mask)
     * }
     */
    public static int __io_uring_prep_poll_mask(int poll_mask) {
        var mh$ = __io_uring_prep_poll_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_prep_poll_mask", poll_mask);
            }
            return (int)mh$.invokeExact(poll_mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_poll_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_poll_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_add(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static FunctionDescriptor io_uring_prep_poll_add$descriptor() {
        return io_uring_prep_poll_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_add(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static MethodHandle io_uring_prep_poll_add$handle() {
        return io_uring_prep_poll_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_add(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static MemorySegment io_uring_prep_poll_add$address() {
        return io_uring_prep_poll_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_add(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static void io_uring_prep_poll_add(MemorySegment sqe, int fd, int poll_mask) {
        var mh$ = io_uring_prep_poll_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_poll_add", sqe, fd, poll_mask);
            }
            mh$.invokeExact(sqe, fd, poll_mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_poll_multishot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_poll_multishot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_multishot(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static FunctionDescriptor io_uring_prep_poll_multishot$descriptor() {
        return io_uring_prep_poll_multishot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_multishot(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static MethodHandle io_uring_prep_poll_multishot$handle() {
        return io_uring_prep_poll_multishot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_multishot(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static MemorySegment io_uring_prep_poll_multishot$address() {
        return io_uring_prep_poll_multishot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_multishot(struct io_uring_sqe *sqe, int fd, unsigned int poll_mask)
     * }
     */
    public static void io_uring_prep_poll_multishot(MemorySegment sqe, int fd, int poll_mask) {
        var mh$ = io_uring_prep_poll_multishot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_poll_multishot", sqe, fd, poll_mask);
            }
            mh$.invokeExact(sqe, fd, poll_mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_poll_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_poll_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_remove(struct io_uring_sqe *sqe, __u64 user_data)
     * }
     */
    public static FunctionDescriptor io_uring_prep_poll_remove$descriptor() {
        return io_uring_prep_poll_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_remove(struct io_uring_sqe *sqe, __u64 user_data)
     * }
     */
    public static MethodHandle io_uring_prep_poll_remove$handle() {
        return io_uring_prep_poll_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_remove(struct io_uring_sqe *sqe, __u64 user_data)
     * }
     */
    public static MemorySegment io_uring_prep_poll_remove$address() {
        return io_uring_prep_poll_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_remove(struct io_uring_sqe *sqe, __u64 user_data)
     * }
     */
    public static void io_uring_prep_poll_remove(MemorySegment sqe, long user_data) {
        var mh$ = io_uring_prep_poll_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_poll_remove", sqe, user_data);
            }
            mh$.invokeExact(sqe, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_poll_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_poll_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_update(struct io_uring_sqe *sqe, __u64 old_user_data, __u64 new_user_data, unsigned int poll_mask, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_poll_update$descriptor() {
        return io_uring_prep_poll_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_update(struct io_uring_sqe *sqe, __u64 old_user_data, __u64 new_user_data, unsigned int poll_mask, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_poll_update$handle() {
        return io_uring_prep_poll_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_update(struct io_uring_sqe *sqe, __u64 old_user_data, __u64 new_user_data, unsigned int poll_mask, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_poll_update$address() {
        return io_uring_prep_poll_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_poll_update(struct io_uring_sqe *sqe, __u64 old_user_data, __u64 new_user_data, unsigned int poll_mask, unsigned int flags)
     * }
     */
    public static void io_uring_prep_poll_update(MemorySegment sqe, long old_user_data, long new_user_data, int poll_mask, int flags) {
        var mh$ = io_uring_prep_poll_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_poll_update", sqe, old_user_data, new_user_data, poll_mask, flags);
            }
            mh$.invokeExact(sqe, old_user_data, new_user_data, poll_mask, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsync(struct io_uring_sqe *sqe, int fd, unsigned int fsync_flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fsync$descriptor() {
        return io_uring_prep_fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsync(struct io_uring_sqe *sqe, int fd, unsigned int fsync_flags)
     * }
     */
    public static MethodHandle io_uring_prep_fsync$handle() {
        return io_uring_prep_fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsync(struct io_uring_sqe *sqe, int fd, unsigned int fsync_flags)
     * }
     */
    public static MemorySegment io_uring_prep_fsync$address() {
        return io_uring_prep_fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fsync(struct io_uring_sqe *sqe, int fd, unsigned int fsync_flags)
     * }
     */
    public static void io_uring_prep_fsync(MemorySegment sqe, int fd, int fsync_flags) {
        var mh$ = io_uring_prep_fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fsync", sqe, fd, fsync_flags);
            }
            mh$.invokeExact(sqe, fd, fsync_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_nop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_nop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_nop(struct io_uring_sqe *sqe)
     * }
     */
    public static FunctionDescriptor io_uring_prep_nop$descriptor() {
        return io_uring_prep_nop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_nop(struct io_uring_sqe *sqe)
     * }
     */
    public static MethodHandle io_uring_prep_nop$handle() {
        return io_uring_prep_nop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_nop(struct io_uring_sqe *sqe)
     * }
     */
    public static MemorySegment io_uring_prep_nop$address() {
        return io_uring_prep_nop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_nop(struct io_uring_sqe *sqe)
     * }
     */
    public static void io_uring_prep_nop(MemorySegment sqe) {
        var mh$ = io_uring_prep_nop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_nop", sqe);
            }
            mh$.invokeExact(sqe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int count, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_timeout$descriptor() {
        return io_uring_prep_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int count, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_timeout$handle() {
        return io_uring_prep_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int count, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_timeout$address() {
        return io_uring_prep_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int count, unsigned int flags)
     * }
     */
    public static void io_uring_prep_timeout(MemorySegment sqe, MemorySegment ts, int count, int flags) {
        var mh$ = io_uring_prep_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_timeout", sqe, ts, count, flags);
            }
            mh$.invokeExact(sqe, ts, count, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_timeout_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_timeout_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_remove(struct io_uring_sqe *sqe, __u64 user_data, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_timeout_remove$descriptor() {
        return io_uring_prep_timeout_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_remove(struct io_uring_sqe *sqe, __u64 user_data, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_timeout_remove$handle() {
        return io_uring_prep_timeout_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_remove(struct io_uring_sqe *sqe, __u64 user_data, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_timeout_remove$address() {
        return io_uring_prep_timeout_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_remove(struct io_uring_sqe *sqe, __u64 user_data, unsigned int flags)
     * }
     */
    public static void io_uring_prep_timeout_remove(MemorySegment sqe, long user_data, int flags) {
        var mh$ = io_uring_prep_timeout_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_timeout_remove", sqe, user_data, flags);
            }
            mh$.invokeExact(sqe, user_data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_timeout_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_timeout_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_update(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, __u64 user_data, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_timeout_update$descriptor() {
        return io_uring_prep_timeout_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_update(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, __u64 user_data, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_timeout_update$handle() {
        return io_uring_prep_timeout_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_update(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, __u64 user_data, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_timeout_update$address() {
        return io_uring_prep_timeout_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_timeout_update(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, __u64 user_data, unsigned int flags)
     * }
     */
    public static void io_uring_prep_timeout_update(MemorySegment sqe, MemorySegment ts, long user_data, int flags) {
        var mh$ = io_uring_prep_timeout_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_timeout_update", sqe, ts, user_data, flags);
            }
            mh$.invokeExact(sqe, ts, user_data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_accept$descriptor() {
        return io_uring_prep_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_accept$handle() {
        return io_uring_prep_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_accept$address() {
        return io_uring_prep_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static void io_uring_prep_accept(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags) {
        var mh$ = io_uring_prep_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_accept", sqe, fd, addr, addrlen, flags);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_accept_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_accept_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags, unsigned int file_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_accept_direct$descriptor() {
        return io_uring_prep_accept_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags, unsigned int file_index)
     * }
     */
    public static MethodHandle io_uring_prep_accept_direct$handle() {
        return io_uring_prep_accept_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags, unsigned int file_index)
     * }
     */
    public static MemorySegment io_uring_prep_accept_direct$address() {
        return io_uring_prep_accept_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags, unsigned int file_index)
     * }
     */
    public static void io_uring_prep_accept_direct(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags, int file_index) {
        var mh$ = io_uring_prep_accept_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_accept_direct", sqe, fd, addr, addrlen, flags, file_index);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen, flags, file_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_multishot_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_multishot_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_multishot_accept$descriptor() {
        return io_uring_prep_multishot_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_multishot_accept$handle() {
        return io_uring_prep_multishot_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_multishot_accept$address() {
        return io_uring_prep_multishot_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static void io_uring_prep_multishot_accept(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags) {
        var mh$ = io_uring_prep_multishot_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_multishot_accept", sqe, fd, addr, addrlen, flags);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_multishot_accept_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_multishot_accept_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_multishot_accept_direct$descriptor() {
        return io_uring_prep_multishot_accept_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_multishot_accept_direct$handle() {
        return io_uring_prep_multishot_accept_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_multishot_accept_direct$address() {
        return io_uring_prep_multishot_accept_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_multishot_accept_direct(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t *addrlen, int flags)
     * }
     */
    public static void io_uring_prep_multishot_accept_direct(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags) {
        var mh$ = io_uring_prep_multishot_accept_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_multishot_accept_direct", sqe, fd, addr, addrlen, flags);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_cancel64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_cancel64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel64(struct io_uring_sqe *sqe, __u64 user_data, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_cancel64$descriptor() {
        return io_uring_prep_cancel64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel64(struct io_uring_sqe *sqe, __u64 user_data, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_cancel64$handle() {
        return io_uring_prep_cancel64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel64(struct io_uring_sqe *sqe, __u64 user_data, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_cancel64$address() {
        return io_uring_prep_cancel64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel64(struct io_uring_sqe *sqe, __u64 user_data, int flags)
     * }
     */
    public static void io_uring_prep_cancel64(MemorySegment sqe, long user_data, int flags) {
        var mh$ = io_uring_prep_cancel64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_cancel64", sqe, user_data, flags);
            }
            mh$.invokeExact(sqe, user_data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel(struct io_uring_sqe *sqe, void *user_data, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_cancel$descriptor() {
        return io_uring_prep_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel(struct io_uring_sqe *sqe, void *user_data, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_cancel$handle() {
        return io_uring_prep_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel(struct io_uring_sqe *sqe, void *user_data, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_cancel$address() {
        return io_uring_prep_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel(struct io_uring_sqe *sqe, void *user_data, int flags)
     * }
     */
    public static void io_uring_prep_cancel(MemorySegment sqe, MemorySegment user_data, int flags) {
        var mh$ = io_uring_prep_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_cancel", sqe, user_data, flags);
            }
            mh$.invokeExact(sqe, user_data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_cancel_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_cancel_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel_fd(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_cancel_fd$descriptor() {
        return io_uring_prep_cancel_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel_fd(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_cancel_fd$handle() {
        return io_uring_prep_cancel_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel_fd(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_cancel_fd$address() {
        return io_uring_prep_cancel_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_cancel_fd(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static void io_uring_prep_cancel_fd(MemorySegment sqe, int fd, int flags) {
        var mh$ = io_uring_prep_cancel_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_cancel_fd", sqe, fd, flags);
            }
            mh$.invokeExact(sqe, fd, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_link_timeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_link_timeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_link_timeout$descriptor() {
        return io_uring_prep_link_timeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_link_timeout$handle() {
        return io_uring_prep_link_timeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_link_timeout$address() {
        return io_uring_prep_link_timeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_link_timeout(struct io_uring_sqe *sqe, struct __kernel_timespec *ts, unsigned int flags)
     * }
     */
    public static void io_uring_prep_link_timeout(MemorySegment sqe, MemorySegment ts, int flags) {
        var mh$ = io_uring_prep_link_timeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_link_timeout", sqe, ts, flags);
            }
            mh$.invokeExact(sqe, ts, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_connect(struct io_uring_sqe *sqe, int fd, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static FunctionDescriptor io_uring_prep_connect$descriptor() {
        return io_uring_prep_connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_connect(struct io_uring_sqe *sqe, int fd, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MethodHandle io_uring_prep_connect$handle() {
        return io_uring_prep_connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_connect(struct io_uring_sqe *sqe, int fd, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MemorySegment io_uring_prep_connect$address() {
        return io_uring_prep_connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_connect(struct io_uring_sqe *sqe, int fd, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static void io_uring_prep_connect(MemorySegment sqe, int fd, MemorySegment addr, int addrlen) {
        var mh$ = io_uring_prep_connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_connect", sqe, fd, addr, addrlen);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_bind(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static FunctionDescriptor io_uring_prep_bind$descriptor() {
        return io_uring_prep_bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_bind(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MethodHandle io_uring_prep_bind$handle() {
        return io_uring_prep_bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_bind(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MemorySegment io_uring_prep_bind$address() {
        return io_uring_prep_bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_bind(struct io_uring_sqe *sqe, int fd, struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static void io_uring_prep_bind(MemorySegment sqe, int fd, MemorySegment addr, int addrlen) {
        var mh$ = io_uring_prep_bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_bind", sqe, fd, addr, addrlen);
            }
            mh$.invokeExact(sqe, fd, addr, addrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_listen(struct io_uring_sqe *sqe, int fd, int backlog)
     * }
     */
    public static FunctionDescriptor io_uring_prep_listen$descriptor() {
        return io_uring_prep_listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_listen(struct io_uring_sqe *sqe, int fd, int backlog)
     * }
     */
    public static MethodHandle io_uring_prep_listen$handle() {
        return io_uring_prep_listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_listen(struct io_uring_sqe *sqe, int fd, int backlog)
     * }
     */
    public static MemorySegment io_uring_prep_listen$address() {
        return io_uring_prep_listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_listen(struct io_uring_sqe *sqe, int fd, int backlog)
     * }
     */
    public static void io_uring_prep_listen(MemorySegment sqe, int fd, int backlog) {
        var mh$ = io_uring_prep_listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_listen", sqe, fd, backlog);
            }
            mh$.invokeExact(sqe, fd, backlog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_files_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_files_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_files_update(struct io_uring_sqe *sqe, int *fds, unsigned int nr_fds, int offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_files_update$descriptor() {
        return io_uring_prep_files_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_files_update(struct io_uring_sqe *sqe, int *fds, unsigned int nr_fds, int offset)
     * }
     */
    public static MethodHandle io_uring_prep_files_update$handle() {
        return io_uring_prep_files_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_files_update(struct io_uring_sqe *sqe, int *fds, unsigned int nr_fds, int offset)
     * }
     */
    public static MemorySegment io_uring_prep_files_update$address() {
        return io_uring_prep_files_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_files_update(struct io_uring_sqe *sqe, int *fds, unsigned int nr_fds, int offset)
     * }
     */
    public static void io_uring_prep_files_update(MemorySegment sqe, MemorySegment fds, int nr_fds, int offset) {
        var mh$ = io_uring_prep_files_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_files_update", sqe, fds, nr_fds, offset);
            }
            mh$.invokeExact(sqe, fds, nr_fds, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fallocate(struct io_uring_sqe *sqe, int fd, int mode, __u64 offset, __u64 len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fallocate$descriptor() {
        return io_uring_prep_fallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fallocate(struct io_uring_sqe *sqe, int fd, int mode, __u64 offset, __u64 len)
     * }
     */
    public static MethodHandle io_uring_prep_fallocate$handle() {
        return io_uring_prep_fallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fallocate(struct io_uring_sqe *sqe, int fd, int mode, __u64 offset, __u64 len)
     * }
     */
    public static MemorySegment io_uring_prep_fallocate$address() {
        return io_uring_prep_fallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fallocate(struct io_uring_sqe *sqe, int fd, int mode, __u64 offset, __u64 len)
     * }
     */
    public static void io_uring_prep_fallocate(MemorySegment sqe, int fd, int mode, long offset, long len) {
        var mh$ = io_uring_prep_fallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fallocate", sqe, fd, mode, offset, len);
            }
            mh$.invokeExact(sqe, fd, mode, offset, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_openat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_openat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)
     * }
     */
    public static FunctionDescriptor io_uring_prep_openat$descriptor() {
        return io_uring_prep_openat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)
     * }
     */
    public static MethodHandle io_uring_prep_openat$handle() {
        return io_uring_prep_openat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)
     * }
     */
    public static MemorySegment io_uring_prep_openat$address() {
        return io_uring_prep_openat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_openat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode)
     * }
     */
    public static void io_uring_prep_openat(MemorySegment sqe, int dfd, MemorySegment path, int flags, int mode) {
        var mh$ = io_uring_prep_openat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_openat", sqe, dfd, path, flags, mode);
            }
            mh$.invokeExact(sqe, dfd, path, flags, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_openat_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_openat_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat_direct(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode, unsigned int file_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_openat_direct$descriptor() {
        return io_uring_prep_openat_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat_direct(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode, unsigned int file_index)
     * }
     */
    public static MethodHandle io_uring_prep_openat_direct$handle() {
        return io_uring_prep_openat_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat_direct(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode, unsigned int file_index)
     * }
     */
    public static MemorySegment io_uring_prep_openat_direct$address() {
        return io_uring_prep_openat_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_openat_direct(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, mode_t mode, unsigned int file_index)
     * }
     */
    public static void io_uring_prep_openat_direct(MemorySegment sqe, int dfd, MemorySegment path, int flags, int mode, int file_index) {
        var mh$ = io_uring_prep_openat_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_openat_direct", sqe, dfd, path, flags, mode, file_index);
            }
            mh$.invokeExact(sqe, dfd, path, flags, mode, file_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close(struct io_uring_sqe *sqe, int fd)
     * }
     */
    public static FunctionDescriptor io_uring_prep_close$descriptor() {
        return io_uring_prep_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close(struct io_uring_sqe *sqe, int fd)
     * }
     */
    public static MethodHandle io_uring_prep_close$handle() {
        return io_uring_prep_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close(struct io_uring_sqe *sqe, int fd)
     * }
     */
    public static MemorySegment io_uring_prep_close$address() {
        return io_uring_prep_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_close(struct io_uring_sqe *sqe, int fd)
     * }
     */
    public static void io_uring_prep_close(MemorySegment sqe, int fd) {
        var mh$ = io_uring_prep_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_close", sqe, fd);
            }
            mh$.invokeExact(sqe, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_close_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_close_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close_direct(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_close_direct$descriptor() {
        return io_uring_prep_close_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close_direct(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static MethodHandle io_uring_prep_close_direct$handle() {
        return io_uring_prep_close_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_close_direct(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static MemorySegment io_uring_prep_close_direct$address() {
        return io_uring_prep_close_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_close_direct(struct io_uring_sqe *sqe, unsigned int file_index)
     * }
     */
    public static void io_uring_prep_close_direct(MemorySegment sqe, int file_index) {
        var mh$ = io_uring_prep_close_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_close_direct", sqe, file_index);
            }
            mh$.invokeExact(sqe, file_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_read$descriptor() {
        return io_uring_prep_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static MethodHandle io_uring_prep_read$handle() {
        return io_uring_prep_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static MemorySegment io_uring_prep_read$address() {
        return io_uring_prep_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_read(struct io_uring_sqe *sqe, int fd, void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static void io_uring_prep_read(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset) {
        var mh$ = io_uring_prep_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_read", sqe, fd, buf, nbytes, offset);
            }
            mh$.invokeExact(sqe, fd, buf, nbytes, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_read_multishot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_read_multishot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_multishot(struct io_uring_sqe *sqe, int fd, unsigned int nbytes, __u64 offset, int buf_group)
     * }
     */
    public static FunctionDescriptor io_uring_prep_read_multishot$descriptor() {
        return io_uring_prep_read_multishot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_multishot(struct io_uring_sqe *sqe, int fd, unsigned int nbytes, __u64 offset, int buf_group)
     * }
     */
    public static MethodHandle io_uring_prep_read_multishot$handle() {
        return io_uring_prep_read_multishot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_read_multishot(struct io_uring_sqe *sqe, int fd, unsigned int nbytes, __u64 offset, int buf_group)
     * }
     */
    public static MemorySegment io_uring_prep_read_multishot$address() {
        return io_uring_prep_read_multishot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_read_multishot(struct io_uring_sqe *sqe, int fd, unsigned int nbytes, __u64 offset, int buf_group)
     * }
     */
    public static void io_uring_prep_read_multishot(MemorySegment sqe, int fd, int nbytes, long offset, int buf_group) {
        var mh$ = io_uring_prep_read_multishot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_read_multishot", sqe, fd, nbytes, offset, buf_group);
            }
            mh$.invokeExact(sqe, fd, nbytes, offset, buf_group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static FunctionDescriptor io_uring_prep_write$descriptor() {
        return io_uring_prep_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static MethodHandle io_uring_prep_write$handle() {
        return io_uring_prep_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static MemorySegment io_uring_prep_write$address() {
        return io_uring_prep_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_write(struct io_uring_sqe *sqe, int fd, const void *buf, unsigned int nbytes, __u64 offset)
     * }
     */
    public static void io_uring_prep_write(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset) {
        var mh$ = io_uring_prep_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_write", sqe, fd, buf, nbytes, offset);
            }
            mh$.invokeExact(sqe, fd, buf, nbytes, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_statx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_statx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_statx(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned int mask, struct statx *statxbuf)
     * }
     */
    public static FunctionDescriptor io_uring_prep_statx$descriptor() {
        return io_uring_prep_statx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_statx(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned int mask, struct statx *statxbuf)
     * }
     */
    public static MethodHandle io_uring_prep_statx$handle() {
        return io_uring_prep_statx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_statx(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned int mask, struct statx *statxbuf)
     * }
     */
    public static MemorySegment io_uring_prep_statx$address() {
        return io_uring_prep_statx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_statx(struct io_uring_sqe *sqe, int dfd, const char *path, int flags, unsigned int mask, struct statx *statxbuf)
     * }
     */
    public static void io_uring_prep_statx(MemorySegment sqe, int dfd, MemorySegment path, int flags, int mask, MemorySegment statxbuf) {
        var mh$ = io_uring_prep_statx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_statx", sqe, dfd, path, flags, mask, statxbuf);
            }
            mh$.invokeExact(sqe, dfd, path, flags, mask, statxbuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fadvise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fadvise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise(struct io_uring_sqe *sqe, int fd, __u64 offset, __u32 len, int advice)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fadvise$descriptor() {
        return io_uring_prep_fadvise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise(struct io_uring_sqe *sqe, int fd, __u64 offset, __u32 len, int advice)
     * }
     */
    public static MethodHandle io_uring_prep_fadvise$handle() {
        return io_uring_prep_fadvise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise(struct io_uring_sqe *sqe, int fd, __u64 offset, __u32 len, int advice)
     * }
     */
    public static MemorySegment io_uring_prep_fadvise$address() {
        return io_uring_prep_fadvise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise(struct io_uring_sqe *sqe, int fd, __u64 offset, __u32 len, int advice)
     * }
     */
    public static void io_uring_prep_fadvise(MemorySegment sqe, int fd, long offset, int len, int advice) {
        var mh$ = io_uring_prep_fadvise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fadvise", sqe, fd, offset, len, advice);
            }
            mh$.invokeExact(sqe, fd, offset, len, advice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_madvise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_madvise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise(struct io_uring_sqe *sqe, void *addr, __u32 length, int advice)
     * }
     */
    public static FunctionDescriptor io_uring_prep_madvise$descriptor() {
        return io_uring_prep_madvise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise(struct io_uring_sqe *sqe, void *addr, __u32 length, int advice)
     * }
     */
    public static MethodHandle io_uring_prep_madvise$handle() {
        return io_uring_prep_madvise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise(struct io_uring_sqe *sqe, void *addr, __u32 length, int advice)
     * }
     */
    public static MemorySegment io_uring_prep_madvise$address() {
        return io_uring_prep_madvise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise(struct io_uring_sqe *sqe, void *addr, __u32 length, int advice)
     * }
     */
    public static void io_uring_prep_madvise(MemorySegment sqe, MemorySegment addr, int length, int advice) {
        var mh$ = io_uring_prep_madvise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_madvise", sqe, addr, length, advice);
            }
            mh$.invokeExact(sqe, addr, length, advice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fadvise64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fadvise64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise64(struct io_uring_sqe *sqe, int fd, __u64 offset, off_t len, int advice)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fadvise64$descriptor() {
        return io_uring_prep_fadvise64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise64(struct io_uring_sqe *sqe, int fd, __u64 offset, off_t len, int advice)
     * }
     */
    public static MethodHandle io_uring_prep_fadvise64$handle() {
        return io_uring_prep_fadvise64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise64(struct io_uring_sqe *sqe, int fd, __u64 offset, off_t len, int advice)
     * }
     */
    public static MemorySegment io_uring_prep_fadvise64$address() {
        return io_uring_prep_fadvise64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fadvise64(struct io_uring_sqe *sqe, int fd, __u64 offset, off_t len, int advice)
     * }
     */
    public static void io_uring_prep_fadvise64(MemorySegment sqe, int fd, long offset, long len, int advice) {
        var mh$ = io_uring_prep_fadvise64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fadvise64", sqe, fd, offset, len, advice);
            }
            mh$.invokeExact(sqe, fd, offset, len, advice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_madvise64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_madvise64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise64(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)
     * }
     */
    public static FunctionDescriptor io_uring_prep_madvise64$descriptor() {
        return io_uring_prep_madvise64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise64(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)
     * }
     */
    public static MethodHandle io_uring_prep_madvise64$handle() {
        return io_uring_prep_madvise64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise64(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)
     * }
     */
    public static MemorySegment io_uring_prep_madvise64$address() {
        return io_uring_prep_madvise64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_madvise64(struct io_uring_sqe *sqe, void *addr, off_t length, int advice)
     * }
     */
    public static void io_uring_prep_madvise64(MemorySegment sqe, MemorySegment addr, long length, int advice) {
        var mh$ = io_uring_prep_madvise64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_madvise64", sqe, addr, length, advice);
            }
            mh$.invokeExact(sqe, addr, length, advice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_send$descriptor() {
        return io_uring_prep_send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_send$handle() {
        return io_uring_prep_send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_send$address() {
        return io_uring_prep_send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags)
     * }
     */
    public static void io_uring_prep_send(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        var mh$ = io_uring_prep_send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_send", sqe, sockfd, buf, len, flags);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_send_bundle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_send_bundle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_bundle(struct io_uring_sqe *sqe, int sockfd, size_t len, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_send_bundle$descriptor() {
        return io_uring_prep_send_bundle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_bundle(struct io_uring_sqe *sqe, int sockfd, size_t len, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_send_bundle$handle() {
        return io_uring_prep_send_bundle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_bundle(struct io_uring_sqe *sqe, int sockfd, size_t len, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_send_bundle$address() {
        return io_uring_prep_send_bundle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_send_bundle(struct io_uring_sqe *sqe, int sockfd, size_t len, int flags)
     * }
     */
    public static void io_uring_prep_send_bundle(MemorySegment sqe, int sockfd, long len, int flags) {
        var mh$ = io_uring_prep_send_bundle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_send_bundle", sqe, sockfd, len, flags);
            }
            mh$.invokeExact(sqe, sockfd, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_send_set_addr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_SHORT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_send_set_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_set_addr(struct io_uring_sqe *sqe, const struct sockaddr *dest_addr, __u16 addr_len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_send_set_addr$descriptor() {
        return io_uring_prep_send_set_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_set_addr(struct io_uring_sqe *sqe, const struct sockaddr *dest_addr, __u16 addr_len)
     * }
     */
    public static MethodHandle io_uring_prep_send_set_addr$handle() {
        return io_uring_prep_send_set_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_set_addr(struct io_uring_sqe *sqe, const struct sockaddr *dest_addr, __u16 addr_len)
     * }
     */
    public static MemorySegment io_uring_prep_send_set_addr$address() {
        return io_uring_prep_send_set_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_send_set_addr(struct io_uring_sqe *sqe, const struct sockaddr *dest_addr, __u16 addr_len)
     * }
     */
    public static void io_uring_prep_send_set_addr(MemorySegment sqe, MemorySegment dest_addr, short addr_len) {
        var mh$ = io_uring_prep_send_set_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_send_set_addr", sqe, dest_addr, addr_len);
            }
            mh$.invokeExact(sqe, dest_addr, addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendto(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static FunctionDescriptor io_uring_prep_sendto$descriptor() {
        return io_uring_prep_sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendto(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MethodHandle io_uring_prep_sendto$handle() {
        return io_uring_prep_sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendto(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static MemorySegment io_uring_prep_sendto$address() {
        return io_uring_prep_sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_sendto(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *addr, socklen_t addrlen)
     * }
     */
    public static void io_uring_prep_sendto(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags, MemorySegment addr, int addrlen) {
        var mh$ = io_uring_prep_sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_sendto", sqe, sockfd, buf, len, flags, addr, addrlen);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags, addr, addrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_send_zc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_send_zc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_send_zc$descriptor() {
        return io_uring_prep_send_zc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags)
     * }
     */
    public static MethodHandle io_uring_prep_send_zc$handle() {
        return io_uring_prep_send_zc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags)
     * }
     */
    public static MemorySegment io_uring_prep_send_zc$address() {
        return io_uring_prep_send_zc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags)
     * }
     */
    public static void io_uring_prep_send_zc(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags, int zc_flags) {
        var mh$ = io_uring_prep_send_zc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_send_zc", sqe, sockfd, buf, len, flags, zc_flags);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags, zc_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_send_zc_fixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_send_zc_fixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc_fixed(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags, unsigned int buf_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_send_zc_fixed$descriptor() {
        return io_uring_prep_send_zc_fixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc_fixed(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags, unsigned int buf_index)
     * }
     */
    public static MethodHandle io_uring_prep_send_zc_fixed$handle() {
        return io_uring_prep_send_zc_fixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc_fixed(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags, unsigned int buf_index)
     * }
     */
    public static MemorySegment io_uring_prep_send_zc_fixed$address() {
        return io_uring_prep_send_zc_fixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_send_zc_fixed(struct io_uring_sqe *sqe, int sockfd, const void *buf, size_t len, int flags, unsigned int zc_flags, unsigned int buf_index)
     * }
     */
    public static void io_uring_prep_send_zc_fixed(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags, int zc_flags, int buf_index) {
        var mh$ = io_uring_prep_send_zc_fixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_send_zc_fixed", sqe, sockfd, buf, len, flags, zc_flags, buf_index);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags, zc_flags, buf_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_sendmsg_zc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_sendmsg_zc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg_zc(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_sendmsg_zc$descriptor() {
        return io_uring_prep_sendmsg_zc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg_zc(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_sendmsg_zc$handle() {
        return io_uring_prep_sendmsg_zc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg_zc(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_sendmsg_zc$address() {
        return io_uring_prep_sendmsg_zc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_sendmsg_zc(struct io_uring_sqe *sqe, int fd, const struct msghdr *msg, unsigned int flags)
     * }
     */
    public static void io_uring_prep_sendmsg_zc(MemorySegment sqe, int fd, MemorySegment msg, int flags) {
        var mh$ = io_uring_prep_sendmsg_zc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_sendmsg_zc", sqe, fd, msg, flags);
            }
            mh$.invokeExact(sqe, fd, msg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_recv$descriptor() {
        return io_uring_prep_recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_recv$handle() {
        return io_uring_prep_recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_recv$address() {
        return io_uring_prep_recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_recv(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static void io_uring_prep_recv(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        var mh$ = io_uring_prep_recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_recv", sqe, sockfd, buf, len, flags);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_recv_multishot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_recv_multishot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv_multishot(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_recv_multishot$descriptor() {
        return io_uring_prep_recv_multishot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv_multishot(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_recv_multishot$handle() {
        return io_uring_prep_recv_multishot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_recv_multishot(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_recv_multishot$address() {
        return io_uring_prep_recv_multishot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_recv_multishot(struct io_uring_sqe *sqe, int sockfd, void *buf, size_t len, int flags)
     * }
     */
    public static void io_uring_prep_recv_multishot(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        var mh$ = io_uring_prep_recv_multishot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_recv_multishot", sqe, sockfd, buf, len, flags);
            }
            mh$.invokeExact(sqe, sockfd, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_validate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_validate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct io_uring_recvmsg_out *io_uring_recvmsg_validate(void *buf, int buf_len, struct msghdr *msgh)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_validate$descriptor() {
        return io_uring_recvmsg_validate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct io_uring_recvmsg_out *io_uring_recvmsg_validate(void *buf, int buf_len, struct msghdr *msgh)
     * }
     */
    public static MethodHandle io_uring_recvmsg_validate$handle() {
        return io_uring_recvmsg_validate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct io_uring_recvmsg_out *io_uring_recvmsg_validate(void *buf, int buf_len, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_validate$address() {
        return io_uring_recvmsg_validate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct io_uring_recvmsg_out *io_uring_recvmsg_validate(void *buf, int buf_len, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_validate(MemorySegment buf, int buf_len, MemorySegment msgh) {
        var mh$ = io_uring_recvmsg_validate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_validate", buf, buf_len, msgh);
            }
            return (MemorySegment)mh$.invokeExact(buf, buf_len, msgh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_name(struct io_uring_recvmsg_out *o)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_name$descriptor() {
        return io_uring_recvmsg_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_name(struct io_uring_recvmsg_out *o)
     * }
     */
    public static MethodHandle io_uring_recvmsg_name$handle() {
        return io_uring_recvmsg_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_name(struct io_uring_recvmsg_out *o)
     * }
     */
    public static MemorySegment io_uring_recvmsg_name$address() {
        return io_uring_recvmsg_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_name(struct io_uring_recvmsg_out *o)
     * }
     */
    public static MemorySegment io_uring_recvmsg_name(MemorySegment o) {
        var mh$ = io_uring_recvmsg_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_name", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_cmsg_firsthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_cmsg_firsthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_firsthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_cmsg_firsthdr$descriptor() {
        return io_uring_recvmsg_cmsg_firsthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_firsthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MethodHandle io_uring_recvmsg_cmsg_firsthdr$handle() {
        return io_uring_recvmsg_cmsg_firsthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_firsthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_cmsg_firsthdr$address() {
        return io_uring_recvmsg_cmsg_firsthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_firsthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_cmsg_firsthdr(MemorySegment o, MemorySegment msgh) {
        var mh$ = io_uring_recvmsg_cmsg_firsthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_cmsg_firsthdr", o, msgh);
            }
            return (MemorySegment)mh$.invokeExact(o, msgh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_cmsg_nexthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_cmsg_nexthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_nexthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh, struct cmsghdr *cmsg)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_cmsg_nexthdr$descriptor() {
        return io_uring_recvmsg_cmsg_nexthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_nexthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh, struct cmsghdr *cmsg)
     * }
     */
    public static MethodHandle io_uring_recvmsg_cmsg_nexthdr$handle() {
        return io_uring_recvmsg_cmsg_nexthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_nexthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh, struct cmsghdr *cmsg)
     * }
     */
    public static MemorySegment io_uring_recvmsg_cmsg_nexthdr$address() {
        return io_uring_recvmsg_cmsg_nexthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *io_uring_recvmsg_cmsg_nexthdr(struct io_uring_recvmsg_out *o, struct msghdr *msgh, struct cmsghdr *cmsg)
     * }
     */
    public static MemorySegment io_uring_recvmsg_cmsg_nexthdr(MemorySegment o, MemorySegment msgh, MemorySegment cmsg) {
        var mh$ = io_uring_recvmsg_cmsg_nexthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_cmsg_nexthdr", o, msgh, cmsg);
            }
            return (MemorySegment)mh$.invokeExact(o, msgh, cmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_payload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_payload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_payload(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_payload$descriptor() {
        return io_uring_recvmsg_payload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_payload(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MethodHandle io_uring_recvmsg_payload$handle() {
        return io_uring_recvmsg_payload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_payload(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_payload$address() {
        return io_uring_recvmsg_payload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *io_uring_recvmsg_payload(struct io_uring_recvmsg_out *o, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_payload(MemorySegment o, MemorySegment msgh) {
        var mh$ = io_uring_recvmsg_payload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_payload", o, msgh);
            }
            return (MemorySegment)mh$.invokeExact(o, msgh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_recvmsg_payload_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_recvmsg_payload_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_recvmsg_payload_length(struct io_uring_recvmsg_out *o, int buf_len, struct msghdr *msgh)
     * }
     */
    public static FunctionDescriptor io_uring_recvmsg_payload_length$descriptor() {
        return io_uring_recvmsg_payload_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_recvmsg_payload_length(struct io_uring_recvmsg_out *o, int buf_len, struct msghdr *msgh)
     * }
     */
    public static MethodHandle io_uring_recvmsg_payload_length$handle() {
        return io_uring_recvmsg_payload_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_recvmsg_payload_length(struct io_uring_recvmsg_out *o, int buf_len, struct msghdr *msgh)
     * }
     */
    public static MemorySegment io_uring_recvmsg_payload_length$address() {
        return io_uring_recvmsg_payload_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int io_uring_recvmsg_payload_length(struct io_uring_recvmsg_out *o, int buf_len, struct msghdr *msgh)
     * }
     */
    public static int io_uring_recvmsg_payload_length(MemorySegment o, int buf_len, MemorySegment msgh) {
        var mh$ = io_uring_recvmsg_payload_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_recvmsg_payload_length", o, buf_len, msgh);
            }
            return (int)mh$.invokeExact(o, buf_len, msgh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_openat2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_openat2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)
     * }
     */
    public static FunctionDescriptor io_uring_prep_openat2$descriptor() {
        return io_uring_prep_openat2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)
     * }
     */
    public static MethodHandle io_uring_prep_openat2$handle() {
        return io_uring_prep_openat2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)
     * }
     */
    public static MemorySegment io_uring_prep_openat2$address() {
        return io_uring_prep_openat2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how)
     * }
     */
    public static void io_uring_prep_openat2(MemorySegment sqe, int dfd, MemorySegment path, MemorySegment how) {
        var mh$ = io_uring_prep_openat2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_openat2", sqe, dfd, path, how);
            }
            mh$.invokeExact(sqe, dfd, path, how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_openat2_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_openat2_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2_direct(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how, unsigned int file_index)
     * }
     */
    public static FunctionDescriptor io_uring_prep_openat2_direct$descriptor() {
        return io_uring_prep_openat2_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2_direct(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how, unsigned int file_index)
     * }
     */
    public static MethodHandle io_uring_prep_openat2_direct$handle() {
        return io_uring_prep_openat2_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2_direct(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how, unsigned int file_index)
     * }
     */
    public static MemorySegment io_uring_prep_openat2_direct$address() {
        return io_uring_prep_openat2_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_openat2_direct(struct io_uring_sqe *sqe, int dfd, const char *path, struct open_how *how, unsigned int file_index)
     * }
     */
    public static void io_uring_prep_openat2_direct(MemorySegment sqe, int dfd, MemorySegment path, MemorySegment how, int file_index) {
        var mh$ = io_uring_prep_openat2_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_openat2_direct", sqe, dfd, path, how, file_index);
            }
            mh$.invokeExact(sqe, dfd, path, how, file_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_epoll_ctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_epoll_ctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_epoll_ctl(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)
     * }
     */
    public static FunctionDescriptor io_uring_prep_epoll_ctl$descriptor() {
        return io_uring_prep_epoll_ctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_epoll_ctl(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)
     * }
     */
    public static MethodHandle io_uring_prep_epoll_ctl$handle() {
        return io_uring_prep_epoll_ctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_epoll_ctl(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)
     * }
     */
    public static MemorySegment io_uring_prep_epoll_ctl$address() {
        return io_uring_prep_epoll_ctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_epoll_ctl(struct io_uring_sqe *sqe, int epfd, int fd, int op, struct epoll_event *ev)
     * }
     */
    public static void io_uring_prep_epoll_ctl(MemorySegment sqe, int epfd, int fd, int op, MemorySegment ev) {
        var mh$ = io_uring_prep_epoll_ctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_epoll_ctl", sqe, epfd, fd, op, ev);
            }
            mh$.invokeExact(sqe, epfd, fd, op, ev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_provide_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_provide_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_provide_buffers(struct io_uring_sqe *sqe, void *addr, int len, int nr, int bgid, int bid)
     * }
     */
    public static FunctionDescriptor io_uring_prep_provide_buffers$descriptor() {
        return io_uring_prep_provide_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_provide_buffers(struct io_uring_sqe *sqe, void *addr, int len, int nr, int bgid, int bid)
     * }
     */
    public static MethodHandle io_uring_prep_provide_buffers$handle() {
        return io_uring_prep_provide_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_provide_buffers(struct io_uring_sqe *sqe, void *addr, int len, int nr, int bgid, int bid)
     * }
     */
    public static MemorySegment io_uring_prep_provide_buffers$address() {
        return io_uring_prep_provide_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_provide_buffers(struct io_uring_sqe *sqe, void *addr, int len, int nr, int bgid, int bid)
     * }
     */
    public static void io_uring_prep_provide_buffers(MemorySegment sqe, MemorySegment addr, int len, int nr, int bgid, int bid) {
        var mh$ = io_uring_prep_provide_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_provide_buffers", sqe, addr, len, nr, bgid, bid);
            }
            mh$.invokeExact(sqe, addr, len, nr, bgid, bid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_remove_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_remove_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_remove_buffers(struct io_uring_sqe *sqe, int nr, int bgid)
     * }
     */
    public static FunctionDescriptor io_uring_prep_remove_buffers$descriptor() {
        return io_uring_prep_remove_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_remove_buffers(struct io_uring_sqe *sqe, int nr, int bgid)
     * }
     */
    public static MethodHandle io_uring_prep_remove_buffers$handle() {
        return io_uring_prep_remove_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_remove_buffers(struct io_uring_sqe *sqe, int nr, int bgid)
     * }
     */
    public static MemorySegment io_uring_prep_remove_buffers$address() {
        return io_uring_prep_remove_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_remove_buffers(struct io_uring_sqe *sqe, int nr, int bgid)
     * }
     */
    public static void io_uring_prep_remove_buffers(MemorySegment sqe, int nr, int bgid) {
        var mh$ = io_uring_prep_remove_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_remove_buffers", sqe, nr, bgid);
            }
            mh$.invokeExact(sqe, nr, bgid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_shutdown(struct io_uring_sqe *sqe, int fd, int how)
     * }
     */
    public static FunctionDescriptor io_uring_prep_shutdown$descriptor() {
        return io_uring_prep_shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_shutdown(struct io_uring_sqe *sqe, int fd, int how)
     * }
     */
    public static MethodHandle io_uring_prep_shutdown$handle() {
        return io_uring_prep_shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_shutdown(struct io_uring_sqe *sqe, int fd, int how)
     * }
     */
    public static MemorySegment io_uring_prep_shutdown$address() {
        return io_uring_prep_shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_shutdown(struct io_uring_sqe *sqe, int fd, int how)
     * }
     */
    public static void io_uring_prep_shutdown(MemorySegment sqe, int fd, int how) {
        var mh$ = io_uring_prep_shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_shutdown", sqe, fd, how);
            }
            mh$.invokeExact(sqe, fd, how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlinkat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_unlinkat$descriptor() {
        return io_uring_prep_unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlinkat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_unlinkat$handle() {
        return io_uring_prep_unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlinkat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_unlinkat$address() {
        return io_uring_prep_unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_unlinkat(struct io_uring_sqe *sqe, int dfd, const char *path, int flags)
     * }
     */
    public static void io_uring_prep_unlinkat(MemorySegment sqe, int dfd, MemorySegment path, int flags) {
        var mh$ = io_uring_prep_unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_unlinkat", sqe, dfd, path, flags);
            }
            mh$.invokeExact(sqe, dfd, path, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlink(struct io_uring_sqe *sqe, const char *path, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_unlink$descriptor() {
        return io_uring_prep_unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlink(struct io_uring_sqe *sqe, const char *path, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_unlink$handle() {
        return io_uring_prep_unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_unlink(struct io_uring_sqe *sqe, const char *path, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_unlink$address() {
        return io_uring_prep_unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_unlink(struct io_uring_sqe *sqe, const char *path, int flags)
     * }
     */
    public static void io_uring_prep_unlink(MemorySegment sqe, MemorySegment path, int flags) {
        var mh$ = io_uring_prep_unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_unlink", sqe, path, flags);
            }
            mh$.invokeExact(sqe, path, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_renameat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_renameat$descriptor() {
        return io_uring_prep_renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_renameat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_renameat$handle() {
        return io_uring_prep_renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_renameat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_renameat$address() {
        return io_uring_prep_renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_renameat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, unsigned int flags)
     * }
     */
    public static void io_uring_prep_renameat(MemorySegment sqe, int olddfd, MemorySegment oldpath, int newdfd, MemorySegment newpath, int flags) {
        var mh$ = io_uring_prep_renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_renameat", sqe, olddfd, oldpath, newdfd, newpath, flags);
            }
            mh$.invokeExact(sqe, olddfd, oldpath, newdfd, newpath, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rename(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath)
     * }
     */
    public static FunctionDescriptor io_uring_prep_rename$descriptor() {
        return io_uring_prep_rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rename(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath)
     * }
     */
    public static MethodHandle io_uring_prep_rename$handle() {
        return io_uring_prep_rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_rename(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath)
     * }
     */
    public static MemorySegment io_uring_prep_rename$address() {
        return io_uring_prep_rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_rename(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath)
     * }
     */
    public static void io_uring_prep_rename(MemorySegment sqe, MemorySegment oldpath, MemorySegment newpath) {
        var mh$ = io_uring_prep_rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_rename", sqe, oldpath, newpath);
            }
            mh$.invokeExact(sqe, oldpath, newpath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_sync_file_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_sync_file_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sync_file_range(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 offset, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_sync_file_range$descriptor() {
        return io_uring_prep_sync_file_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sync_file_range(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 offset, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_sync_file_range$handle() {
        return io_uring_prep_sync_file_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_sync_file_range(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 offset, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_sync_file_range$address() {
        return io_uring_prep_sync_file_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_sync_file_range(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 offset, int flags)
     * }
     */
    public static void io_uring_prep_sync_file_range(MemorySegment sqe, int fd, int len, long offset, int flags) {
        var mh$ = io_uring_prep_sync_file_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_sync_file_range", sqe, fd, len, offset, flags);
            }
            mh$.invokeExact(sqe, fd, len, offset, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_mkdirat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdirat(struct io_uring_sqe *sqe, int dfd, const char *path, mode_t mode)
     * }
     */
    public static FunctionDescriptor io_uring_prep_mkdirat$descriptor() {
        return io_uring_prep_mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdirat(struct io_uring_sqe *sqe, int dfd, const char *path, mode_t mode)
     * }
     */
    public static MethodHandle io_uring_prep_mkdirat$handle() {
        return io_uring_prep_mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdirat(struct io_uring_sqe *sqe, int dfd, const char *path, mode_t mode)
     * }
     */
    public static MemorySegment io_uring_prep_mkdirat$address() {
        return io_uring_prep_mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdirat(struct io_uring_sqe *sqe, int dfd, const char *path, mode_t mode)
     * }
     */
    public static void io_uring_prep_mkdirat(MemorySegment sqe, int dfd, MemorySegment path, int mode) {
        var mh$ = io_uring_prep_mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_mkdirat", sqe, dfd, path, mode);
            }
            mh$.invokeExact(sqe, dfd, path, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_mkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdir(struct io_uring_sqe *sqe, const char *path, mode_t mode)
     * }
     */
    public static FunctionDescriptor io_uring_prep_mkdir$descriptor() {
        return io_uring_prep_mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdir(struct io_uring_sqe *sqe, const char *path, mode_t mode)
     * }
     */
    public static MethodHandle io_uring_prep_mkdir$handle() {
        return io_uring_prep_mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdir(struct io_uring_sqe *sqe, const char *path, mode_t mode)
     * }
     */
    public static MemorySegment io_uring_prep_mkdir$address() {
        return io_uring_prep_mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_mkdir(struct io_uring_sqe *sqe, const char *path, mode_t mode)
     * }
     */
    public static void io_uring_prep_mkdir(MemorySegment sqe, MemorySegment path, int mode) {
        var mh$ = io_uring_prep_mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_mkdir", sqe, path, mode);
            }
            mh$.invokeExact(sqe, path, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlinkat(struct io_uring_sqe *sqe, const char *target, int newdirfd, const char *linkpath)
     * }
     */
    public static FunctionDescriptor io_uring_prep_symlinkat$descriptor() {
        return io_uring_prep_symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlinkat(struct io_uring_sqe *sqe, const char *target, int newdirfd, const char *linkpath)
     * }
     */
    public static MethodHandle io_uring_prep_symlinkat$handle() {
        return io_uring_prep_symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlinkat(struct io_uring_sqe *sqe, const char *target, int newdirfd, const char *linkpath)
     * }
     */
    public static MemorySegment io_uring_prep_symlinkat$address() {
        return io_uring_prep_symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_symlinkat(struct io_uring_sqe *sqe, const char *target, int newdirfd, const char *linkpath)
     * }
     */
    public static void io_uring_prep_symlinkat(MemorySegment sqe, MemorySegment target, int newdirfd, MemorySegment linkpath) {
        var mh$ = io_uring_prep_symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_symlinkat", sqe, target, newdirfd, linkpath);
            }
            mh$.invokeExact(sqe, target, newdirfd, linkpath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlink(struct io_uring_sqe *sqe, const char *target, const char *linkpath)
     * }
     */
    public static FunctionDescriptor io_uring_prep_symlink$descriptor() {
        return io_uring_prep_symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlink(struct io_uring_sqe *sqe, const char *target, const char *linkpath)
     * }
     */
    public static MethodHandle io_uring_prep_symlink$handle() {
        return io_uring_prep_symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_symlink(struct io_uring_sqe *sqe, const char *target, const char *linkpath)
     * }
     */
    public static MemorySegment io_uring_prep_symlink$address() {
        return io_uring_prep_symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_symlink(struct io_uring_sqe *sqe, const char *target, const char *linkpath)
     * }
     */
    public static void io_uring_prep_symlink(MemorySegment sqe, MemorySegment target, MemorySegment linkpath) {
        var mh$ = io_uring_prep_symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_symlink", sqe, target, linkpath);
            }
            mh$.invokeExact(sqe, target, linkpath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_linkat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_linkat$descriptor() {
        return io_uring_prep_linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_linkat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_linkat$handle() {
        return io_uring_prep_linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_linkat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_linkat$address() {
        return io_uring_prep_linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_linkat(struct io_uring_sqe *sqe, int olddfd, const char *oldpath, int newdfd, const char *newpath, int flags)
     * }
     */
    public static void io_uring_prep_linkat(MemorySegment sqe, int olddfd, MemorySegment oldpath, int newdfd, MemorySegment newpath, int flags) {
        var mh$ = io_uring_prep_linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_linkat", sqe, olddfd, oldpath, newdfd, newpath, flags);
            }
            mh$.invokeExact(sqe, olddfd, oldpath, newdfd, newpath, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath, int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_link$descriptor() {
        return io_uring_prep_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath, int flags)
     * }
     */
    public static MethodHandle io_uring_prep_link$handle() {
        return io_uring_prep_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_link(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath, int flags)
     * }
     */
    public static MemorySegment io_uring_prep_link$address() {
        return io_uring_prep_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_link(struct io_uring_sqe *sqe, const char *oldpath, const char *newpath, int flags)
     * }
     */
    public static void io_uring_prep_link(MemorySegment sqe, MemorySegment oldpath, MemorySegment newpath, int flags) {
        var mh$ = io_uring_prep_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_link", sqe, oldpath, newpath, flags);
            }
            mh$.invokeExact(sqe, oldpath, newpath, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_msg_ring_cqe_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_msg_ring_cqe_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_cqe_flags(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags, unsigned int cqe_flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_msg_ring_cqe_flags$descriptor() {
        return io_uring_prep_msg_ring_cqe_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_cqe_flags(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags, unsigned int cqe_flags)
     * }
     */
    public static MethodHandle io_uring_prep_msg_ring_cqe_flags$handle() {
        return io_uring_prep_msg_ring_cqe_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_cqe_flags(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags, unsigned int cqe_flags)
     * }
     */
    public static MemorySegment io_uring_prep_msg_ring_cqe_flags$address() {
        return io_uring_prep_msg_ring_cqe_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_cqe_flags(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags, unsigned int cqe_flags)
     * }
     */
    public static void io_uring_prep_msg_ring_cqe_flags(MemorySegment sqe, int fd, int len, long data, int flags, int cqe_flags) {
        var mh$ = io_uring_prep_msg_ring_cqe_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_msg_ring_cqe_flags", sqe, fd, len, data, flags, cqe_flags);
            }
            mh$.invokeExact(sqe, fd, len, data, flags, cqe_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_msg_ring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_msg_ring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_msg_ring$descriptor() {
        return io_uring_prep_msg_ring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_msg_ring$handle() {
        return io_uring_prep_msg_ring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_msg_ring$address() {
        return io_uring_prep_msg_ring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring(struct io_uring_sqe *sqe, int fd, unsigned int len, __u64 data, unsigned int flags)
     * }
     */
    public static void io_uring_prep_msg_ring(MemorySegment sqe, int fd, int len, long data, int flags) {
        var mh$ = io_uring_prep_msg_ring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_msg_ring", sqe, fd, len, data, flags);
            }
            mh$.invokeExact(sqe, fd, len, data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_msg_ring_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_msg_ring_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd(struct io_uring_sqe *sqe, int fd, int source_fd, int target_fd, __u64 data, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_msg_ring_fd$descriptor() {
        return io_uring_prep_msg_ring_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd(struct io_uring_sqe *sqe, int fd, int source_fd, int target_fd, __u64 data, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_msg_ring_fd$handle() {
        return io_uring_prep_msg_ring_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd(struct io_uring_sqe *sqe, int fd, int source_fd, int target_fd, __u64 data, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_msg_ring_fd$address() {
        return io_uring_prep_msg_ring_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd(struct io_uring_sqe *sqe, int fd, int source_fd, int target_fd, __u64 data, unsigned int flags)
     * }
     */
    public static void io_uring_prep_msg_ring_fd(MemorySegment sqe, int fd, int source_fd, int target_fd, long data, int flags) {
        var mh$ = io_uring_prep_msg_ring_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_msg_ring_fd", sqe, fd, source_fd, target_fd, data, flags);
            }
            mh$.invokeExact(sqe, fd, source_fd, target_fd, data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_msg_ring_fd_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_LONG_LONG,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_msg_ring_fd_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd_alloc(struct io_uring_sqe *sqe, int fd, int source_fd, __u64 data, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_msg_ring_fd_alloc$descriptor() {
        return io_uring_prep_msg_ring_fd_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd_alloc(struct io_uring_sqe *sqe, int fd, int source_fd, __u64 data, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_msg_ring_fd_alloc$handle() {
        return io_uring_prep_msg_ring_fd_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd_alloc(struct io_uring_sqe *sqe, int fd, int source_fd, __u64 data, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_msg_ring_fd_alloc$address() {
        return io_uring_prep_msg_ring_fd_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_msg_ring_fd_alloc(struct io_uring_sqe *sqe, int fd, int source_fd, __u64 data, unsigned int flags)
     * }
     */
    public static void io_uring_prep_msg_ring_fd_alloc(MemorySegment sqe, int fd, int source_fd, long data, int flags) {
        var mh$ = io_uring_prep_msg_ring_fd_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_msg_ring_fd_alloc", sqe, fd, source_fd, data, flags);
            }
            mh$.invokeExact(sqe, fd, source_fd, data, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_getxattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_getxattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_getxattr(struct io_uring_sqe *sqe, const char *name, char *value, const char *path, unsigned int len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_getxattr$descriptor() {
        return io_uring_prep_getxattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_getxattr(struct io_uring_sqe *sqe, const char *name, char *value, const char *path, unsigned int len)
     * }
     */
    public static MethodHandle io_uring_prep_getxattr$handle() {
        return io_uring_prep_getxattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_getxattr(struct io_uring_sqe *sqe, const char *name, char *value, const char *path, unsigned int len)
     * }
     */
    public static MemorySegment io_uring_prep_getxattr$address() {
        return io_uring_prep_getxattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_getxattr(struct io_uring_sqe *sqe, const char *name, char *value, const char *path, unsigned int len)
     * }
     */
    public static void io_uring_prep_getxattr(MemorySegment sqe, MemorySegment name, MemorySegment value, MemorySegment path, int len) {
        var mh$ = io_uring_prep_getxattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_getxattr", sqe, name, value, path, len);
            }
            mh$.invokeExact(sqe, name, value, path, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_setxattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_setxattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_setxattr(struct io_uring_sqe *sqe, const char *name, const char *value, const char *path, int flags, unsigned int len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_setxattr$descriptor() {
        return io_uring_prep_setxattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_setxattr(struct io_uring_sqe *sqe, const char *name, const char *value, const char *path, int flags, unsigned int len)
     * }
     */
    public static MethodHandle io_uring_prep_setxattr$handle() {
        return io_uring_prep_setxattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_setxattr(struct io_uring_sqe *sqe, const char *name, const char *value, const char *path, int flags, unsigned int len)
     * }
     */
    public static MemorySegment io_uring_prep_setxattr$address() {
        return io_uring_prep_setxattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_setxattr(struct io_uring_sqe *sqe, const char *name, const char *value, const char *path, int flags, unsigned int len)
     * }
     */
    public static void io_uring_prep_setxattr(MemorySegment sqe, MemorySegment name, MemorySegment value, MemorySegment path, int flags, int len) {
        var mh$ = io_uring_prep_setxattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_setxattr", sqe, name, value, path, flags, len);
            }
            mh$.invokeExact(sqe, name, value, path, flags, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fgetxattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fgetxattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fgetxattr(struct io_uring_sqe *sqe, int fd, const char *name, char *value, unsigned int len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fgetxattr$descriptor() {
        return io_uring_prep_fgetxattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fgetxattr(struct io_uring_sqe *sqe, int fd, const char *name, char *value, unsigned int len)
     * }
     */
    public static MethodHandle io_uring_prep_fgetxattr$handle() {
        return io_uring_prep_fgetxattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fgetxattr(struct io_uring_sqe *sqe, int fd, const char *name, char *value, unsigned int len)
     * }
     */
    public static MemorySegment io_uring_prep_fgetxattr$address() {
        return io_uring_prep_fgetxattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fgetxattr(struct io_uring_sqe *sqe, int fd, const char *name, char *value, unsigned int len)
     * }
     */
    public static void io_uring_prep_fgetxattr(MemorySegment sqe, int fd, MemorySegment name, MemorySegment value, int len) {
        var mh$ = io_uring_prep_fgetxattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fgetxattr", sqe, fd, name, value, len);
            }
            mh$.invokeExact(sqe, fd, name, value, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fsetxattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fsetxattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsetxattr(struct io_uring_sqe *sqe, int fd, const char *name, const char *value, int flags, unsigned int len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fsetxattr$descriptor() {
        return io_uring_prep_fsetxattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsetxattr(struct io_uring_sqe *sqe, int fd, const char *name, const char *value, int flags, unsigned int len)
     * }
     */
    public static MethodHandle io_uring_prep_fsetxattr$handle() {
        return io_uring_prep_fsetxattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fsetxattr(struct io_uring_sqe *sqe, int fd, const char *name, const char *value, int flags, unsigned int len)
     * }
     */
    public static MemorySegment io_uring_prep_fsetxattr$address() {
        return io_uring_prep_fsetxattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fsetxattr(struct io_uring_sqe *sqe, int fd, const char *name, const char *value, int flags, unsigned int len)
     * }
     */
    public static void io_uring_prep_fsetxattr(MemorySegment sqe, int fd, MemorySegment name, MemorySegment value, int flags, int len) {
        var mh$ = io_uring_prep_fsetxattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fsetxattr", sqe, fd, name, value, flags, len);
            }
            mh$.invokeExact(sqe, fd, name, value, flags, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_socket$descriptor() {
        return io_uring_prep_socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_socket$handle() {
        return io_uring_prep_socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_socket$address() {
        return io_uring_prep_socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_socket(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static void io_uring_prep_socket(MemorySegment sqe, int domain, int type, int protocol, int flags) {
        var mh$ = io_uring_prep_socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_socket", sqe, domain, type, protocol, flags);
            }
            mh$.invokeExact(sqe, domain, type, protocol, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_socket_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_socket_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int file_index, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_socket_direct$descriptor() {
        return io_uring_prep_socket_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int file_index, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_socket_direct$handle() {
        return io_uring_prep_socket_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int file_index, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_socket_direct$address() {
        return io_uring_prep_socket_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int file_index, unsigned int flags)
     * }
     */
    public static void io_uring_prep_socket_direct(MemorySegment sqe, int domain, int type, int protocol, int file_index, int flags) {
        var mh$ = io_uring_prep_socket_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_socket_direct", sqe, domain, type, protocol, file_index, flags);
            }
            mh$.invokeExact(sqe, domain, type, protocol, file_index, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_socket_direct_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_socket_direct_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct_alloc(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_socket_direct_alloc$descriptor() {
        return io_uring_prep_socket_direct_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct_alloc(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_socket_direct_alloc$handle() {
        return io_uring_prep_socket_direct_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct_alloc(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_socket_direct_alloc$address() {
        return io_uring_prep_socket_direct_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_socket_direct_alloc(struct io_uring_sqe *sqe, int domain, int type, int protocol, unsigned int flags)
     * }
     */
    public static void io_uring_prep_socket_direct_alloc(MemorySegment sqe, int domain, int type, int protocol, int flags) {
        var mh$ = io_uring_prep_socket_direct_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_socket_direct_alloc", sqe, domain, type, protocol, flags);
            }
            mh$.invokeExact(sqe, domain, type, protocol, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_cmd_sock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_cmd_sock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cmd_sock(struct io_uring_sqe *sqe, int cmd_op, int fd, int level, int optname, void *optval, int optlen)
     * }
     */
    public static FunctionDescriptor io_uring_prep_cmd_sock$descriptor() {
        return io_uring_prep_cmd_sock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cmd_sock(struct io_uring_sqe *sqe, int cmd_op, int fd, int level, int optname, void *optval, int optlen)
     * }
     */
    public static MethodHandle io_uring_prep_cmd_sock$handle() {
        return io_uring_prep_cmd_sock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_cmd_sock(struct io_uring_sqe *sqe, int cmd_op, int fd, int level, int optname, void *optval, int optlen)
     * }
     */
    public static MemorySegment io_uring_prep_cmd_sock$address() {
        return io_uring_prep_cmd_sock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_cmd_sock(struct io_uring_sqe *sqe, int cmd_op, int fd, int level, int optname, void *optval, int optlen)
     * }
     */
    public static void io_uring_prep_cmd_sock(MemorySegment sqe, int cmd_op, int fd, int level, int optname, MemorySegment optval, int optlen) {
        var mh$ = io_uring_prep_cmd_sock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_cmd_sock", sqe, cmd_op, fd, level, optname, optval, optlen);
            }
            mh$.invokeExact(sqe, cmd_op, fd, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_waitid(struct io_uring_sqe *sqe, idtype_t idtype, id_t id, siginfo_t *infop, int options, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_waitid$descriptor() {
        return io_uring_prep_waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_waitid(struct io_uring_sqe *sqe, idtype_t idtype, id_t id, siginfo_t *infop, int options, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_waitid$handle() {
        return io_uring_prep_waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_waitid(struct io_uring_sqe *sqe, idtype_t idtype, id_t id, siginfo_t *infop, int options, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_waitid$address() {
        return io_uring_prep_waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_waitid(struct io_uring_sqe *sqe, idtype_t idtype, id_t id, siginfo_t *infop, int options, unsigned int flags)
     * }
     */
    public static void io_uring_prep_waitid(MemorySegment sqe, int idtype, int id, MemorySegment infop, int options, int flags) {
        var mh$ = io_uring_prep_waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_waitid", sqe, idtype, id, infop, options, flags);
            }
            mh$.invokeExact(sqe, idtype, id, infop, options, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_futex_wake {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_futex_wake");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wake(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_futex_wake$descriptor() {
        return io_uring_prep_futex_wake.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wake(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_futex_wake$handle() {
        return io_uring_prep_futex_wake.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wake(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_futex_wake$address() {
        return io_uring_prep_futex_wake.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wake(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static void io_uring_prep_futex_wake(MemorySegment sqe, MemorySegment futex, long val, long mask, int futex_flags, int flags) {
        var mh$ = io_uring_prep_futex_wake.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_futex_wake", sqe, futex, val, mask, futex_flags, flags);
            }
            mh$.invokeExact(sqe, futex, val, mask, futex_flags, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_futex_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_LONG,
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_futex_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wait(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_futex_wait$descriptor() {
        return io_uring_prep_futex_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wait(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_futex_wait$handle() {
        return io_uring_prep_futex_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wait(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_futex_wait$address() {
        return io_uring_prep_futex_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_wait(struct io_uring_sqe *sqe, uint32_t *futex, uint64_t val, uint64_t mask, uint32_t futex_flags, unsigned int flags)
     * }
     */
    public static void io_uring_prep_futex_wait(MemorySegment sqe, MemorySegment futex, long val, long mask, int futex_flags, int flags) {
        var mh$ = io_uring_prep_futex_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_futex_wait", sqe, futex, val, mask, futex_flags, flags);
            }
            mh$.invokeExact(sqe, futex, val, mask, futex_flags, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_futex_waitv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_futex_waitv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_waitv(struct io_uring_sqe *sqe, struct futex_waitv *futex, uint32_t nr_futex, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_futex_waitv$descriptor() {
        return io_uring_prep_futex_waitv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_waitv(struct io_uring_sqe *sqe, struct futex_waitv *futex, uint32_t nr_futex, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_futex_waitv$handle() {
        return io_uring_prep_futex_waitv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_waitv(struct io_uring_sqe *sqe, struct futex_waitv *futex, uint32_t nr_futex, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_futex_waitv$address() {
        return io_uring_prep_futex_waitv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_futex_waitv(struct io_uring_sqe *sqe, struct futex_waitv *futex, uint32_t nr_futex, unsigned int flags)
     * }
     */
    public static void io_uring_prep_futex_waitv(MemorySegment sqe, MemorySegment futex, int nr_futex, int flags) {
        var mh$ = io_uring_prep_futex_waitv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_futex_waitv", sqe, futex, nr_futex, flags);
            }
            mh$.invokeExact(sqe, futex, nr_futex, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_fixed_fd_install {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_fixed_fd_install");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fixed_fd_install(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_prep_fixed_fd_install$descriptor() {
        return io_uring_prep_fixed_fd_install.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fixed_fd_install(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_prep_fixed_fd_install$handle() {
        return io_uring_prep_fixed_fd_install.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_fixed_fd_install(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_prep_fixed_fd_install$address() {
        return io_uring_prep_fixed_fd_install.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_fixed_fd_install(struct io_uring_sqe *sqe, int fd, unsigned int flags)
     * }
     */
    public static void io_uring_prep_fixed_fd_install(MemorySegment sqe, int fd, int flags) {
        var mh$ = io_uring_prep_fixed_fd_install.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_fixed_fd_install", sqe, fd, flags);
            }
            mh$.invokeExact(sqe, fd, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_prep_ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_LONG
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_prep_ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_prep_ftruncate(struct io_uring_sqe *sqe, int fd, loff_t len)
     * }
     */
    public static FunctionDescriptor io_uring_prep_ftruncate$descriptor() {
        return io_uring_prep_ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_prep_ftruncate(struct io_uring_sqe *sqe, int fd, loff_t len)
     * }
     */
    public static MethodHandle io_uring_prep_ftruncate$handle() {
        return io_uring_prep_ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_prep_ftruncate(struct io_uring_sqe *sqe, int fd, loff_t len)
     * }
     */
    public static MemorySegment io_uring_prep_ftruncate$address() {
        return io_uring_prep_ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_prep_ftruncate(struct io_uring_sqe *sqe, int fd, loff_t len)
     * }
     */
    public static void io_uring_prep_ftruncate(MemorySegment sqe, int fd, long len) {
        var mh$ = io_uring_prep_ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_prep_ftruncate", sqe, fd, len);
            }
            mh$.invokeExact(sqe, fd, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sq_ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sq_ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_ready(const struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_sq_ready$descriptor() {
        return io_uring_sq_ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_ready(const struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_sq_ready$handle() {
        return io_uring_sq_ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_ready(const struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_sq_ready$address() {
        return io_uring_sq_ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_ready(const struct io_uring *ring)
     * }
     */
    public static int io_uring_sq_ready(MemorySegment ring) {
        var mh$ = io_uring_sq_ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sq_ready", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sq_space_left {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sq_space_left");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_space_left(const struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_sq_space_left$descriptor() {
        return io_uring_sq_space_left.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_space_left(const struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_sq_space_left$handle() {
        return io_uring_sq_space_left.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_space_left(const struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_sq_space_left$address() {
        return io_uring_sq_space_left.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int io_uring_sq_space_left(const struct io_uring *ring)
     * }
     */
    public static int io_uring_sq_space_left(MemorySegment ring) {
        var mh$ = io_uring_sq_space_left.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sq_space_left", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_sqring_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_sqring_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_sqring_wait$descriptor() {
        return io_uring_sqring_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_sqring_wait$handle() {
        return io_uring_sqring_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_sqring_wait$address() {
        return io_uring_sqring_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_sqring_wait(struct io_uring *ring)
     * }
     */
    public static int io_uring_sqring_wait(MemorySegment ring) {
        var mh$ = io_uring_sqring_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_sqring_wait", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cq_ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cq_ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_cq_ready(const struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_cq_ready$descriptor() {
        return io_uring_cq_ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_cq_ready(const struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_cq_ready$handle() {
        return io_uring_cq_ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned int io_uring_cq_ready(const struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_cq_ready$address() {
        return io_uring_cq_ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned int io_uring_cq_ready(const struct io_uring *ring)
     * }
     */
    public static int io_uring_cq_ready(MemorySegment ring) {
        var mh$ = io_uring_cq_ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cq_ready", ring);
            }
            return (int)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cq_has_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_BOOL,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cq_has_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_has_overflow(const struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_cq_has_overflow$descriptor() {
        return io_uring_cq_has_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_has_overflow(const struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_cq_has_overflow$handle() {
        return io_uring_cq_has_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_has_overflow(const struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_cq_has_overflow$address() {
        return io_uring_cq_has_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool io_uring_cq_has_overflow(const struct io_uring *ring)
     * }
     */
    public static boolean io_uring_cq_has_overflow(MemorySegment ring) {
        var mh$ = io_uring_cq_has_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cq_has_overflow", ring);
            }
            return (boolean)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cq_eventfd_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_BOOL,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cq_eventfd_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_eventfd_enabled(const struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_cq_eventfd_enabled$descriptor() {
        return io_uring_cq_eventfd_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_eventfd_enabled(const struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_cq_eventfd_enabled$handle() {
        return io_uring_cq_eventfd_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool io_uring_cq_eventfd_enabled(const struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_cq_eventfd_enabled$address() {
        return io_uring_cq_eventfd_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool io_uring_cq_eventfd_enabled(const struct io_uring *ring)
     * }
     */
    public static boolean io_uring_cq_eventfd_enabled(MemorySegment ring) {
        var mh$ = io_uring_cq_eventfd_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cq_eventfd_enabled", ring);
            }
            return (boolean)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_cq_eventfd_toggle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_BOOL
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_cq_eventfd_toggle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_cq_eventfd_toggle(struct io_uring *ring, bool enabled)
     * }
     */
    public static FunctionDescriptor io_uring_cq_eventfd_toggle$descriptor() {
        return io_uring_cq_eventfd_toggle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_cq_eventfd_toggle(struct io_uring *ring, bool enabled)
     * }
     */
    public static MethodHandle io_uring_cq_eventfd_toggle$handle() {
        return io_uring_cq_eventfd_toggle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_cq_eventfd_toggle(struct io_uring *ring, bool enabled)
     * }
     */
    public static MemorySegment io_uring_cq_eventfd_toggle$address() {
        return io_uring_cq_eventfd_toggle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_cq_eventfd_toggle(struct io_uring *ring, bool enabled)
     * }
     */
    public static int io_uring_cq_eventfd_toggle(MemorySegment ring, boolean enabled) {
        var mh$ = io_uring_cq_eventfd_toggle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_cq_eventfd_toggle", ring, enabled);
            }
            return (int)mh$.invokeExact(ring, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_wait_cqe_nr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_wait_cqe_nr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe_nr(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr)
     * }
     */
    public static FunctionDescriptor io_uring_wait_cqe_nr$descriptor() {
        return io_uring_wait_cqe_nr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe_nr(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr)
     * }
     */
    public static MethodHandle io_uring_wait_cqe_nr$handle() {
        return io_uring_wait_cqe_nr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe_nr(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr)
     * }
     */
    public static MemorySegment io_uring_wait_cqe_nr$address() {
        return io_uring_wait_cqe_nr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe_nr(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int wait_nr)
     * }
     */
    public static int io_uring_wait_cqe_nr(MemorySegment ring, MemorySegment cqe_ptr, int wait_nr) {
        var mh$ = io_uring_wait_cqe_nr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_wait_cqe_nr", ring, cqe_ptr, wait_nr);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, wait_nr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_peek_cqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_peek_cqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int *nr_available)
     * }
     */
    public static FunctionDescriptor __io_uring_peek_cqe$descriptor() {
        return __io_uring_peek_cqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int *nr_available)
     * }
     */
    public static MethodHandle __io_uring_peek_cqe$handle() {
        return __io_uring_peek_cqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int *nr_available)
     * }
     */
    public static MemorySegment __io_uring_peek_cqe$address() {
        return __io_uring_peek_cqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr, unsigned int *nr_available)
     * }
     */
    public static int __io_uring_peek_cqe(MemorySegment ring, MemorySegment cqe_ptr, MemorySegment nr_available) {
        var mh$ = __io_uring_peek_cqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_peek_cqe", ring, cqe_ptr, nr_available);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr, nr_available);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_peek_cqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_peek_cqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static FunctionDescriptor io_uring_peek_cqe$descriptor() {
        return io_uring_peek_cqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static MethodHandle io_uring_peek_cqe$handle() {
        return io_uring_peek_cqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static MemorySegment io_uring_peek_cqe$address() {
        return io_uring_peek_cqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_peek_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static int io_uring_peek_cqe(MemorySegment ring, MemorySegment cqe_ptr) {
        var mh$ = io_uring_peek_cqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_peek_cqe", ring, cqe_ptr);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_wait_cqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_wait_cqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static FunctionDescriptor io_uring_wait_cqe$descriptor() {
        return io_uring_wait_cqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static MethodHandle io_uring_wait_cqe$handle() {
        return io_uring_wait_cqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static MemorySegment io_uring_wait_cqe$address() {
        return io_uring_wait_cqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)
     * }
     */
    public static int io_uring_wait_cqe(MemorySegment ring, MemorySegment cqe_ptr) {
        var mh$ = io_uring_wait_cqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_wait_cqe", ring, cqe_ptr);
            }
            return (int)mh$.invokeExact(ring, cqe_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _io_uring_get_sqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("_io_uring_get_sqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *_io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor _io_uring_get_sqe$descriptor() {
        return _io_uring_get_sqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *_io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MethodHandle _io_uring_get_sqe$handle() {
        return _io_uring_get_sqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *_io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MemorySegment _io_uring_get_sqe$address() {
        return _io_uring_get_sqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct io_uring_sqe *_io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MemorySegment _io_uring_get_sqe(MemorySegment ring) {
        var mh$ = _io_uring_get_sqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_io_uring_get_sqe", ring);
            }
            return (MemorySegment)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_mask(__u32 ring_entries)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_mask$descriptor() {
        return io_uring_buf_ring_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_mask(__u32 ring_entries)
     * }
     */
    public static MethodHandle io_uring_buf_ring_mask$handle() {
        return io_uring_buf_ring_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_mask(__u32 ring_entries)
     * }
     */
    public static MemorySegment io_uring_buf_ring_mask$address() {
        return io_uring_buf_ring_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_mask(__u32 ring_entries)
     * }
     */
    public static int io_uring_buf_ring_mask(int ring_entries) {
        var mh$ = io_uring_buf_ring_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_mask", ring_entries);
            }
            return (int)mh$.invokeExact(ring_entries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_init(struct io_uring_buf_ring *br)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_init$descriptor() {
        return io_uring_buf_ring_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_init(struct io_uring_buf_ring *br)
     * }
     */
    public static MethodHandle io_uring_buf_ring_init$handle() {
        return io_uring_buf_ring_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_init(struct io_uring_buf_ring *br)
     * }
     */
    public static MemorySegment io_uring_buf_ring_init$address() {
        return io_uring_buf_ring_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_init(struct io_uring_buf_ring *br)
     * }
     */
    public static void io_uring_buf_ring_init(MemorySegment br) {
        var mh$ = io_uring_buf_ring_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_init", br);
            }
            mh$.invokeExact(br);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_SHORT,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_add(struct io_uring_buf_ring *br, void *addr, unsigned int len, unsigned short bid, int mask, int buf_offset)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_add$descriptor() {
        return io_uring_buf_ring_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_add(struct io_uring_buf_ring *br, void *addr, unsigned int len, unsigned short bid, int mask, int buf_offset)
     * }
     */
    public static MethodHandle io_uring_buf_ring_add$handle() {
        return io_uring_buf_ring_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_add(struct io_uring_buf_ring *br, void *addr, unsigned int len, unsigned short bid, int mask, int buf_offset)
     * }
     */
    public static MemorySegment io_uring_buf_ring_add$address() {
        return io_uring_buf_ring_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_add(struct io_uring_buf_ring *br, void *addr, unsigned int len, unsigned short bid, int mask, int buf_offset)
     * }
     */
    public static void io_uring_buf_ring_add(MemorySegment br, MemorySegment addr, int len, short bid, int mask, int buf_offset) {
        var mh$ = io_uring_buf_ring_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_add", br, addr, len, bid, mask, buf_offset);
            }
            mh$.invokeExact(br, addr, len, bid, mask, buf_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_advance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_advance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_advance(struct io_uring_buf_ring *br, int count)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_advance$descriptor() {
        return io_uring_buf_ring_advance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_advance(struct io_uring_buf_ring *br, int count)
     * }
     */
    public static MethodHandle io_uring_buf_ring_advance$handle() {
        return io_uring_buf_ring_advance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_advance(struct io_uring_buf_ring *br, int count)
     * }
     */
    public static MemorySegment io_uring_buf_ring_advance$address() {
        return io_uring_buf_ring_advance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_advance(struct io_uring_buf_ring *br, int count)
     * }
     */
    public static void io_uring_buf_ring_advance(MemorySegment br, int count) {
        var mh$ = io_uring_buf_ring_advance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_advance", br, count);
            }
            mh$.invokeExact(br, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __io_uring_buf_ring_cq_advance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("__io_uring_buf_ring_cq_advance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int cq_count, int buf_count)
     * }
     */
    public static FunctionDescriptor __io_uring_buf_ring_cq_advance$descriptor() {
        return __io_uring_buf_ring_cq_advance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int cq_count, int buf_count)
     * }
     */
    public static MethodHandle __io_uring_buf_ring_cq_advance$handle() {
        return __io_uring_buf_ring_cq_advance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int cq_count, int buf_count)
     * }
     */
    public static MemorySegment __io_uring_buf_ring_cq_advance$address() {
        return __io_uring_buf_ring_cq_advance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int cq_count, int buf_count)
     * }
     */
    public static void __io_uring_buf_ring_cq_advance(MemorySegment ring, MemorySegment br, int cq_count, int buf_count) {
        var mh$ = __io_uring_buf_ring_cq_advance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__io_uring_buf_ring_cq_advance", ring, br, cq_count, buf_count);
            }
            mh$.invokeExact(ring, br, cq_count, buf_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_cq_advance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_cq_advance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int count)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_cq_advance$descriptor() {
        return io_uring_buf_ring_cq_advance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int count)
     * }
     */
    public static MethodHandle io_uring_buf_ring_cq_advance$handle() {
        return io_uring_buf_ring_cq_advance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int count)
     * }
     */
    public static MemorySegment io_uring_buf_ring_cq_advance$address() {
        return io_uring_buf_ring_cq_advance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void io_uring_buf_ring_cq_advance(struct io_uring *ring, struct io_uring_buf_ring *br, int count)
     * }
     */
    public static void io_uring_buf_ring_cq_advance(MemorySegment ring, MemorySegment br, int count) {
        var mh$ = io_uring_buf_ring_cq_advance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_cq_advance", ring, br, count);
            }
            mh$.invokeExact(ring, br, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_buf_ring_available {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT,
            liburingtest.C_POINTER,
            liburingtest.C_POINTER,
            liburingtest.C_SHORT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_buf_ring_available");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_available(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned short bgid)
     * }
     */
    public static FunctionDescriptor io_uring_buf_ring_available$descriptor() {
        return io_uring_buf_ring_available.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_available(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned short bgid)
     * }
     */
    public static MethodHandle io_uring_buf_ring_available$handle() {
        return io_uring_buf_ring_available.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_available(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned short bgid)
     * }
     */
    public static MemorySegment io_uring_buf_ring_available$address() {
        return io_uring_buf_ring_available.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int io_uring_buf_ring_available(struct io_uring *ring, struct io_uring_buf_ring *br, unsigned short bgid)
     * }
     */
    public static int io_uring_buf_ring_available(MemorySegment ring, MemorySegment br, short bgid) {
        var mh$ = io_uring_buf_ring_available.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_buf_ring_available", ring, br, bgid);
            }
            return (int)mh$.invokeExact(ring, br, bgid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_get_sqe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_POINTER,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_get_sqe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static FunctionDescriptor io_uring_get_sqe$descriptor() {
        return io_uring_get_sqe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MethodHandle io_uring_get_sqe$handle() {
        return io_uring_get_sqe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_get_sqe$address() {
        return io_uring_get_sqe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring)
     * }
     */
    public static MemorySegment io_uring_get_sqe(MemorySegment ring) {
        var mh$ = io_uring_get_sqe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_get_sqe", ring);
            }
            return (MemorySegment)mh$.invokeExact(ring);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_mlock_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_mlock_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size(unsigned int entries, unsigned int flags)
     * }
     */
    public static FunctionDescriptor io_uring_mlock_size$descriptor() {
        return io_uring_mlock_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size(unsigned int entries, unsigned int flags)
     * }
     */
    public static MethodHandle io_uring_mlock_size$handle() {
        return io_uring_mlock_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size(unsigned int entries, unsigned int flags)
     * }
     */
    public static MemorySegment io_uring_mlock_size$address() {
        return io_uring_mlock_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size(unsigned int entries, unsigned int flags)
     * }
     */
    public static long io_uring_mlock_size(int entries, int flags) {
        var mh$ = io_uring_mlock_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_mlock_size", entries, flags);
            }
            return (long)mh$.invokeExact(entries, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_mlock_size_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_LONG,
            liburingtest.C_INT,
            liburingtest.C_POINTER
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_mlock_size_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size_params(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static FunctionDescriptor io_uring_mlock_size_params$descriptor() {
        return io_uring_mlock_size_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size_params(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static MethodHandle io_uring_mlock_size_params$handle() {
        return io_uring_mlock_size_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size_params(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static MemorySegment io_uring_mlock_size_params$address() {
        return io_uring_mlock_size_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t io_uring_mlock_size_params(unsigned int entries, struct io_uring_params *p)
     * }
     */
    public static long io_uring_mlock_size_params(int entries, MemorySegment p) {
        var mh$ = io_uring_mlock_size_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_mlock_size_params", entries, p);
            }
            return (long)mh$.invokeExact(entries, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_major_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_major_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_major_version()
     * }
     */
    public static FunctionDescriptor io_uring_major_version$descriptor() {
        return io_uring_major_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_major_version()
     * }
     */
    public static MethodHandle io_uring_major_version$handle() {
        return io_uring_major_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_major_version()
     * }
     */
    public static MemorySegment io_uring_major_version$address() {
        return io_uring_major_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_major_version()
     * }
     */
    public static int io_uring_major_version() {
        var mh$ = io_uring_major_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_major_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_minor_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_INT    );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_minor_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int io_uring_minor_version()
     * }
     */
    public static FunctionDescriptor io_uring_minor_version$descriptor() {
        return io_uring_minor_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int io_uring_minor_version()
     * }
     */
    public static MethodHandle io_uring_minor_version$handle() {
        return io_uring_minor_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int io_uring_minor_version()
     * }
     */
    public static MemorySegment io_uring_minor_version$address() {
        return io_uring_minor_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int io_uring_minor_version()
     * }
     */
    public static int io_uring_minor_version() {
        var mh$ = io_uring_minor_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_minor_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class io_uring_check_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            liburingtest.C_BOOL,
            liburingtest.C_INT,
            liburingtest.C_INT
        );

        public static final MemorySegment ADDR = liburingtest.findOrThrow("io_uring_check_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool io_uring_check_version(int major, int minor)
     * }
     */
    public static FunctionDescriptor io_uring_check_version$descriptor() {
        return io_uring_check_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool io_uring_check_version(int major, int minor)
     * }
     */
    public static MethodHandle io_uring_check_version$handle() {
        return io_uring_check_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool io_uring_check_version(int major, int minor)
     * }
     */
    public static MemorySegment io_uring_check_version$address() {
        return io_uring_check_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool io_uring_check_version(int major, int minor)
     * }
     */
    public static boolean io_uring_check_version(int major, int minor) {
        var mh$ = io_uring_check_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("io_uring_check_version", major, minor);
            }
            return (boolean)mh$.invokeExact(major, minor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final int PF_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_UNIX 1
     * }
     */
    public static int PF_UNIX() {
        return PF_UNIX;
    }
    private static final int PF_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_FILE 1
     * }
     */
    public static int PF_FILE() {
        return PF_FILE;
    }
    private static final int PF_ROUTE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_ROUTE 16
     * }
     */
    public static int PF_ROUTE() {
        return PF_ROUTE;
    }
    private static final int AF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AF_UNSPEC 0
     * }
     */
    public static int AF_UNSPEC() {
        return AF_UNSPEC;
    }
    private static final int AF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_LOCAL 1
     * }
     */
    public static int AF_LOCAL() {
        return AF_LOCAL;
    }
    private static final int AF_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_UNIX 1
     * }
     */
    public static int AF_UNIX() {
        return AF_UNIX;
    }
    private static final int AF_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_FILE 1
     * }
     */
    public static int AF_FILE() {
        return AF_FILE;
    }
    private static final int AF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AF_INET 2
     * }
     */
    public static int AF_INET() {
        return AF_INET;
    }
    private static final int AF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AF_AX25 3
     * }
     */
    public static int AF_AX25() {
        return AF_AX25;
    }
    private static final int AF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AF_IPX 4
     * }
     */
    public static int AF_IPX() {
        return AF_IPX;
    }
    private static final int AF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AF_APPLETALK 5
     * }
     */
    public static int AF_APPLETALK() {
        return AF_APPLETALK;
    }
    private static final int AF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AF_NETROM 6
     * }
     */
    public static int AF_NETROM() {
        return AF_NETROM;
    }
    private static final int AF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define AF_BRIDGE 7
     * }
     */
    public static int AF_BRIDGE() {
        return AF_BRIDGE;
    }
    private static final int AF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AF_ATMPVC 8
     * }
     */
    public static int AF_ATMPVC() {
        return AF_ATMPVC;
    }
    private static final int AF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AF_X25 9
     * }
     */
    public static int AF_X25() {
        return AF_X25;
    }
    private static final int AF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define AF_INET6 10
     * }
     */
    public static int AF_INET6() {
        return AF_INET6;
    }
    private static final int AF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define AF_ROSE 11
     * }
     */
    public static int AF_ROSE() {
        return AF_ROSE;
    }
    private static final int AF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define AF_DECnet 12
     * }
     */
    public static int AF_DECnet() {
        return AF_DECnet;
    }
    private static final int AF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define AF_NETBEUI 13
     * }
     */
    public static int AF_NETBEUI() {
        return AF_NETBEUI;
    }
    private static final int AF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define AF_SECURITY 14
     * }
     */
    public static int AF_SECURITY() {
        return AF_SECURITY;
    }
    private static final int AF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define AF_KEY 15
     * }
     */
    public static int AF_KEY() {
        return AF_KEY;
    }
    private static final int AF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AF_NETLINK 16
     * }
     */
    public static int AF_NETLINK() {
        return AF_NETLINK;
    }
    private static final int AF_ROUTE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AF_ROUTE 16
     * }
     */
    public static int AF_ROUTE() {
        return AF_ROUTE;
    }
    private static final int AF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define AF_PACKET 17
     * }
     */
    public static int AF_PACKET() {
        return AF_PACKET;
    }
    private static final int AF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define AF_ASH 18
     * }
     */
    public static int AF_ASH() {
        return AF_ASH;
    }
    private static final int AF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define AF_ECONET 19
     * }
     */
    public static int AF_ECONET() {
        return AF_ECONET;
    }
    private static final int AF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AF_ATMSVC 20
     * }
     */
    public static int AF_ATMSVC() {
        return AF_ATMSVC;
    }
    private static final int AF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define AF_RDS 21
     * }
     */
    public static int AF_RDS() {
        return AF_RDS;
    }
    private static final int AF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define AF_SNA 22
     * }
     */
    public static int AF_SNA() {
        return AF_SNA;
    }
    private static final int AF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define AF_IRDA 23
     * }
     */
    public static int AF_IRDA() {
        return AF_IRDA;
    }
    private static final int AF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define AF_PPPOX 24
     * }
     */
    public static int AF_PPPOX() {
        return AF_PPPOX;
    }
    private static final int AF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define AF_WANPIPE 25
     * }
     */
    public static int AF_WANPIPE() {
        return AF_WANPIPE;
    }
    private static final int AF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define AF_LLC 26
     * }
     */
    public static int AF_LLC() {
        return AF_LLC;
    }
    private static final int AF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define AF_IB 27
     * }
     */
    public static int AF_IB() {
        return AF_IB;
    }
    private static final int AF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AF_MPLS 28
     * }
     */
    public static int AF_MPLS() {
        return AF_MPLS;
    }
    private static final int AF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define AF_CAN 29
     * }
     */
    public static int AF_CAN() {
        return AF_CAN;
    }
    private static final int AF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AF_TIPC 30
     * }
     */
    public static int AF_TIPC() {
        return AF_TIPC;
    }
    private static final int AF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define AF_BLUETOOTH 31
     * }
     */
    public static int AF_BLUETOOTH() {
        return AF_BLUETOOTH;
    }
    private static final int AF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AF_IUCV 32
     * }
     */
    public static int AF_IUCV() {
        return AF_IUCV;
    }
    private static final int AF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AF_RXRPC 33
     * }
     */
    public static int AF_RXRPC() {
        return AF_RXRPC;
    }
    private static final int AF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define AF_ISDN 34
     * }
     */
    public static int AF_ISDN() {
        return AF_ISDN;
    }
    private static final int AF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define AF_PHONET 35
     * }
     */
    public static int AF_PHONET() {
        return AF_PHONET;
    }
    private static final int AF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define AF_IEEE802154 36
     * }
     */
    public static int AF_IEEE802154() {
        return AF_IEEE802154;
    }
    private static final int AF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define AF_CAIF 37
     * }
     */
    public static int AF_CAIF() {
        return AF_CAIF;
    }
    private static final int AF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define AF_ALG 38
     * }
     */
    public static int AF_ALG() {
        return AF_ALG;
    }
    private static final int AF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define AF_NFC 39
     * }
     */
    public static int AF_NFC() {
        return AF_NFC;
    }
    private static final int AF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AF_VSOCK 40
     * }
     */
    public static int AF_VSOCK() {
        return AF_VSOCK;
    }
    private static final int AF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AF_KCM 41
     * }
     */
    public static int AF_KCM() {
        return AF_KCM;
    }
    private static final int AF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define AF_QIPCRTR 42
     * }
     */
    public static int AF_QIPCRTR() {
        return AF_QIPCRTR;
    }
    private static final int AF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define AF_SMC 43
     * }
     */
    public static int AF_SMC() {
        return AF_SMC;
    }
    private static final int AF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AF_XDP 44
     * }
     */
    public static int AF_XDP() {
        return AF_XDP;
    }
    private static final int AF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define AF_MCTP 45
     * }
     */
    public static int AF_MCTP() {
        return AF_MCTP;
    }
    private static final int AF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define AF_MAX 46
     * }
     */
    public static int AF_MAX() {
        return AF_MAX;
    }
    private static final long __SOCKADDR_COMMON_SIZE = 2L;
    /**
     * {@snippet lang=c :
     * #define __SOCKADDR_COMMON_SIZE 2
     * }
     */
    public static long __SOCKADDR_COMMON_SIZE() {
        return __SOCKADDR_COMMON_SIZE;
    }
    private static final long _SS_PADSIZE = 118L;
    /**
     * {@snippet lang=c :
     * #define _SS_PADSIZE 118
     * }
     */
    public static long _SS_PADSIZE() {
        return _SS_PADSIZE;
    }
    private static final int SO_GET_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_GET_FILTER 26
     * }
     */
    public static int SO_GET_FILTER() {
        return SO_GET_FILTER;
    }
    private static final int SCM_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SCM_WIFI_STATUS 41
     * }
     */
    public static int SCM_WIFI_STATUS() {
        return SCM_WIFI_STATUS;
    }
    private static final int SO_DETACH_BPF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_BPF 27
     * }
     */
    public static int SO_DETACH_BPF() {
        return SO_DETACH_BPF;
    }
    private static final int SCM_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SCM_TXTIME 61
     * }
     */
    public static int SCM_TXTIME() {
        return SCM_TXTIME;
    }
    private static final int SO_TIMESTAMP = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP 29
     * }
     */
    public static int SO_TIMESTAMP() {
        return SO_TIMESTAMP;
    }
    private static final int SO_TIMESTAMPNS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS 35
     * }
     */
    public static int SO_TIMESTAMPNS() {
        return SO_TIMESTAMPNS;
    }
    private static final int SO_TIMESTAMPING = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING 37
     * }
     */
    public static int SO_TIMESTAMPING() {
        return SO_TIMESTAMPING;
    }
    private static final int SO_RCVTIMEO = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO 20
     * }
     */
    public static int SO_RCVTIMEO() {
        return SO_RCVTIMEO;
    }
    private static final int SO_SNDTIMEO = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO 21
     * }
     */
    public static int SO_SNDTIMEO() {
        return SO_SNDTIMEO;
    }
    private static final int SCM_TIMESTAMP = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMP 29
     * }
     */
    public static int SCM_TIMESTAMP() {
        return SCM_TIMESTAMP;
    }
    private static final int SCM_TIMESTAMPNS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPNS 35
     * }
     */
    public static int SCM_TIMESTAMPNS() {
        return SCM_TIMESTAMPNS;
    }
    private static final int SCM_TIMESTAMPING = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING 37
     * }
     */
    public static int SCM_TIMESTAMPING() {
        return SCM_TIMESTAMPING;
    }
    private static final long UTIME_NOW = 1073741823L;
    /**
     * {@snippet lang=c :
     * #define UTIME_NOW 1073741823
     * }
     */
    public static long UTIME_NOW() {
        return UTIME_NOW;
    }
    private static final long UTIME_OMIT = 1073741822L;
    /**
     * {@snippet lang=c :
     * #define UTIME_OMIT 1073741822
     * }
     */
    public static long UTIME_OMIT() {
        return UTIME_OMIT;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFBLK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define S_IFBLK 24576
     * }
     */
    public static int S_IFBLK() {
        return S_IFBLK;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define S_IFIFO 4096
     * }
     */
    public static int S_IFIFO() {
        return S_IFIFO;
    }
    private static final int S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define S_IFLNK 40960
     * }
     */
    public static int S_IFLNK() {
        return S_IFLNK;
    }
    private static final int S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define S_IFSOCK 49152
     * }
     */
    public static int S_IFSOCK() {
        return S_IFSOCK;
    }
    private static final int S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define S_ISUID 2048
     * }
     */
    public static int S_ISUID() {
        return S_ISUID;
    }
    private static final int S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define S_ISGID 1024
     * }
     */
    public static int S_ISGID() {
        return S_ISGID;
    }
    private static final int S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISVTX 512
     * }
     */
    public static int S_ISVTX() {
        return S_ISVTX;
    }
    private static final int S_IRUSR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IRUSR 256
     * }
     */
    public static int S_IRUSR() {
        return S_IRUSR;
    }
    private static final int S_IWUSR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWUSR 128
     * }
     */
    public static int S_IWUSR() {
        return S_IWUSR;
    }
    private static final int S_IXUSR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IXUSR 64
     * }
     */
    public static int S_IXUSR() {
        return S_IXUSR;
    }
    private static final int S_IRWXU = (int)448L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXU 448
     * }
     */
    public static int S_IRWXU() {
        return S_IRWXU;
    }
    private static final int S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }
    private static final int S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }
    private static final int S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }
    private static final int S_IRGRP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define S_IRGRP 32
     * }
     */
    public static int S_IRGRP() {
        return S_IRGRP;
    }
    private static final int S_IWGRP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define S_IWGRP 16
     * }
     */
    public static int S_IWGRP() {
        return S_IWGRP;
    }
    private static final int S_IXGRP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define S_IXGRP 8
     * }
     */
    public static int S_IXGRP() {
        return S_IXGRP;
    }
    private static final int S_IRWXG = (int)56L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXG 56
     * }
     */
    public static int S_IRWXG() {
        return S_IRWXG;
    }
    private static final int S_IROTH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define S_IROTH 4
     * }
     */
    public static int S_IROTH() {
        return S_IROTH;
    }
    private static final int S_IWOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define S_IWOTH 2
     * }
     */
    public static int S_IWOTH() {
        return S_IWOTH;
    }
    private static final int S_IXOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define S_IXOTH 1
     * }
     */
    public static int S_IXOTH() {
        return S_IXOTH;
    }
    private static final int S_IRWXO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXO 7
     * }
     */
    public static int S_IRWXO() {
        return S_IRWXO;
    }
    private static final int ACCESSPERMS = (int)511L;
    /**
     * {@snippet lang=c :
     * #define ACCESSPERMS 511
     * }
     */
    public static int ACCESSPERMS() {
        return ACCESSPERMS;
    }
    private static final int ALLPERMS = (int)4095L;
    /**
     * {@snippet lang=c :
     * #define ALLPERMS 4095
     * }
     */
    public static int ALLPERMS() {
        return ALLPERMS;
    }
    private static final int DEFFILEMODE = (int)438L;
    /**
     * {@snippet lang=c :
     * #define DEFFILEMODE 438
     * }
     */
    public static int DEFFILEMODE() {
        return DEFFILEMODE;
    }
    private static final int UIO_MAXIOV = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define UIO_MAXIOV 1024
     * }
     */
    public static int UIO_MAXIOV() {
        return UIO_MAXIOV;
    }
    private static final int EWOULDBLOCK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 11
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int EDEADLOCK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 35
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int ENOTSUP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 95
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final int SIGIO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 29
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final int SIGCLD = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGCLD 17
     * }
     */
    public static int SIGCLD() {
        return SIGCLD;
    }
    private static final int _NSIG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _NSIG 65
     * }
     */
    public static int _NSIG() {
        return _NSIG;
    }
    private static final long __SI_PAD_SIZE = 28L;
    /**
     * {@snippet lang=c :
     * #define __SI_PAD_SIZE 28
     * }
     */
    public static long __SI_PAD_SIZE() {
        return __SI_PAD_SIZE;
    }
    private static final long __SIGEV_PAD_SIZE = 12L;
    /**
     * {@snippet lang=c :
     * #define __SIGEV_PAD_SIZE 12
     * }
     */
    public static long __SIGEV_PAD_SIZE() {
        return __SIGEV_PAD_SIZE;
    }
    private static final int NSIG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define NSIG 65
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SA_RESETHAND = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 2147483648
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOMASK = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define SA_NOMASK 1073741824
     * }
     */
    public static int SA_NOMASK() {
        return SA_NOMASK;
    }
    private static final int SA_ONESHOT = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define SA_ONESHOT 2147483648
     * }
     */
    public static int SA_ONESHOT() {
        return SA_ONESHOT;
    }
    private static final int SA_STACK = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define SA_STACK 134217728
     * }
     */
    public static int SA_STACK() {
        return SA_STACK;
    }
    private static final int FP_XSTATE_MAGIC1 = (int)1179670611L;
    /**
     * {@snippet lang=c :
     * #define FP_XSTATE_MAGIC1 1179670611
     * }
     */
    public static int FP_XSTATE_MAGIC1() {
        return FP_XSTATE_MAGIC1;
    }
    private static final int FP_XSTATE_MAGIC2 = (int)1179670597L;
    /**
     * {@snippet lang=c :
     * #define FP_XSTATE_MAGIC2 1179670597
     * }
     */
    public static int FP_XSTATE_MAGIC2() {
        return FP_XSTATE_MAGIC2;
    }
    private static final long FP_XSTATE_MAGIC2_SIZE = 4L;
    /**
     * {@snippet lang=c :
     * #define FP_XSTATE_MAGIC2_SIZE 4
     * }
     */
    public static long FP_XSTATE_MAGIC2_SIZE() {
        return FP_XSTATE_MAGIC2_SIZE;
    }
    private static final int NGREG = (int)23L;
    /**
     * {@snippet lang=c :
     * #define NGREG 23
     * }
     */
    public static int NGREG() {
        return NGREG;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI64_PREFIX "l"
     * }
     */
    public static MemorySegment __PRI64_PREFIX() {
        class Holder {
            static final MemorySegment __PRI64_PREFIX
                = liburingtest.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRI64_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRIPTR_PREFIX "l"
     * }
     */
    public static MemorySegment __PRIPTR_PREFIX() {
        class Holder {
            static final MemorySegment __PRIPTR_PREFIX
                = liburingtest.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRIPTR_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "d"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "d"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "ld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "d"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "d"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "ld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "d"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "ld"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "ld"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "ld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "i"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "i"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "li"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "i"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "i"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "li"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "i"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "li"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "li"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "li"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "o"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "o"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "lo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "o"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "o"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "lo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "o"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "lo"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "lo"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "lo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "u"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "u"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "lu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "u"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "u"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "lu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "u"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "lu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "lu"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "lu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "x"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "x"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "lx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "x"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "x"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "lx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "x"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "lx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "lx"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "lx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "X"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "X"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "lX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "X"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "X"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "lX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "X"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "lX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "lX"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "lX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "ld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "li"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "lo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "lu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "lx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "lX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "ld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "ld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "ld"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "ld"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "ld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "li"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "li"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "li"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "li"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "li"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "lu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "lu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "lu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "lu"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "lu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = liburingtest.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "lo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "lo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "lo"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "lo"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "lo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "lx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "lx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = liburingtest.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "lx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "lx"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "lx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "ld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "li"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "lo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "lu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "lx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = liburingtest.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int O_NDELAY = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define O_NDELAY 2048
     * }
     */
    public static int O_NDELAY() {
        return O_NDELAY;
    }
    private static final int O_FSYNC = (int)1052672L;
    /**
     * {@snippet lang=c :
     * #define O_FSYNC 1052672
     * }
     */
    public static int O_FSYNC() {
        return O_FSYNC;
    }
    private static final int __O_TMPFILE = (int)4259840L;
    /**
     * {@snippet lang=c :
     * #define __O_TMPFILE 4259840
     * }
     */
    public static int __O_TMPFILE() {
        return __O_TMPFILE;
    }
    private static final int O_DIRECTORY = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define O_DIRECTORY 65536
     * }
     */
    public static int O_DIRECTORY() {
        return O_DIRECTORY;
    }
    private static final int O_NOFOLLOW = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define O_NOFOLLOW 131072
     * }
     */
    public static int O_NOFOLLOW() {
        return O_NOFOLLOW;
    }
    private static final int O_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define O_CLOEXEC 524288
     * }
     */
    public static int O_CLOEXEC() {
        return O_CLOEXEC;
    }
    private static final int O_DSYNC = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define O_DSYNC 4096
     * }
     */
    public static int O_DSYNC() {
        return O_DSYNC;
    }
    private static final int O_RSYNC = (int)1052672L;
    /**
     * {@snippet lang=c :
     * #define O_RSYNC 1052672
     * }
     */
    public static int O_RSYNC() {
        return O_RSYNC;
    }
    private static final int F_SETOWN = (int)8L;
    /**
     * {@snippet lang=c :
     * #define F_SETOWN 8
     * }
     */
    public static int F_SETOWN() {
        return F_SETOWN;
    }
    private static final int F_GETOWN = (int)9L;
    /**
     * {@snippet lang=c :
     * #define F_GETOWN 9
     * }
     */
    public static int F_GETOWN() {
        return F_GETOWN;
    }
    private static final int FAPPEND = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FAPPEND 1024
     * }
     */
    public static int FAPPEND() {
        return FAPPEND;
    }
    private static final int FFSYNC = (int)1052672L;
    /**
     * {@snippet lang=c :
     * #define FFSYNC 1052672
     * }
     */
    public static int FFSYNC() {
        return FFSYNC;
    }
    private static final int FASYNC = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define FASYNC 8192
     * }
     */
    public static int FASYNC() {
        return FASYNC;
    }
    private static final int FNONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FNONBLOCK 2048
     * }
     */
    public static int FNONBLOCK() {
        return FNONBLOCK;
    }
    private static final int FNDELAY = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FNDELAY 2048
     * }
     */
    public static int FNDELAY() {
        return FNDELAY;
    }
    private static final int POSIX_FADV_DONTNEED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POSIX_FADV_DONTNEED 4
     * }
     */
    public static int POSIX_FADV_DONTNEED() {
        return POSIX_FADV_DONTNEED;
    }
    private static final int POSIX_FADV_NOREUSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POSIX_FADV_NOREUSE 5
     * }
     */
    public static int POSIX_FADV_NOREUSE() {
        return POSIX_FADV_NOREUSE;
    }
    private static final int AT_FDCWD = (int)-100L;
    /**
     * {@snippet lang=c :
     * #define AT_FDCWD -100
     * }
     */
    public static int AT_FDCWD() {
        return AT_FDCWD;
    }
    private static final long __NCPUBITS = 64L;
    /**
     * {@snippet lang=c :
     * #define __NCPUBITS 64
     * }
     */
    public static long __NCPUBITS() {
        return __NCPUBITS;
    }
    private static final int __WCLONE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCLONE 2147483648
     * }
     */
    public static int __WCLONE() {
        return __WCLONE;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int _IOC_NRMASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _IOC_NRMASK 255
     * }
     */
    public static int _IOC_NRMASK() {
        return _IOC_NRMASK;
    }
    private static final int _IOC_TYPEMASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _IOC_TYPEMASK 255
     * }
     */
    public static int _IOC_TYPEMASK() {
        return _IOC_TYPEMASK;
    }
    private static final int _IOC_SIZEMASK = (int)16383L;
    /**
     * {@snippet lang=c :
     * #define _IOC_SIZEMASK 16383
     * }
     */
    public static int _IOC_SIZEMASK() {
        return _IOC_SIZEMASK;
    }
    private static final int _IOC_DIRMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOC_DIRMASK 3
     * }
     */
    public static int _IOC_DIRMASK() {
        return _IOC_DIRMASK;
    }
    private static final int _IOC_TYPESHIFT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _IOC_TYPESHIFT 8
     * }
     */
    public static int _IOC_TYPESHIFT() {
        return _IOC_TYPESHIFT;
    }
    private static final int _IOC_SIZESHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IOC_SIZESHIFT 16
     * }
     */
    public static int _IOC_SIZESHIFT() {
        return _IOC_SIZESHIFT;
    }
    private static final int _IOC_DIRSHIFT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _IOC_DIRSHIFT 30
     * }
     */
    public static int _IOC_DIRSHIFT() {
        return _IOC_DIRSHIFT;
    }
    private static final int _IOC_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOC_NONE 0
     * }
     */
    public static int _IOC_NONE() {
        return _IOC_NONE;
    }
    private static final int _IOC_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOC_WRITE 1
     * }
     */
    public static int _IOC_WRITE() {
        return _IOC_WRITE;
    }
    private static final int _IOC_READ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IOC_READ 2
     * }
     */
    public static int _IOC_READ() {
        return _IOC_READ;
    }
    private static final int IOC_IN = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define IOC_IN 1073741824
     * }
     */
    public static int IOC_IN() {
        return IOC_IN;
    }
    private static final int IOC_OUT = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define IOC_OUT 2147483648
     * }
     */
    public static int IOC_OUT() {
        return IOC_OUT;
    }
    private static final int IOC_INOUT = (int)3221225472L;
    /**
     * {@snippet lang=c :
     * #define IOC_INOUT 3221225472
     * }
     */
    public static int IOC_INOUT() {
        return IOC_INOUT;
    }
    private static final int IOCSIZE_MASK = (int)1073676288L;
    /**
     * {@snippet lang=c :
     * #define IOCSIZE_MASK 1073676288
     * }
     */
    public static int IOCSIZE_MASK() {
        return IOCSIZE_MASK;
    }
    private static final int IOCSIZE_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IOCSIZE_SHIFT 16
     * }
     */
    public static int IOCSIZE_SHIFT() {
        return IOCSIZE_SHIFT;
    }
    /**
     * {@snippet lang=c :
     * #define FSCRYPT_KEY_DESC_PREFIX "fscrypt:"
     * }
     */
    public static MemorySegment FSCRYPT_KEY_DESC_PREFIX() {
        class Holder {
            static final MemorySegment FSCRYPT_KEY_DESC_PREFIX
                = liburingtest.LIBRARY_ARENA.allocateFrom("fscrypt:");
        }
        return Holder.FSCRYPT_KEY_DESC_PREFIX;
    }
    private static final long FS_IOC_SET_ENCRYPTION_POLICY = 2148296211L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_SET_ENCRYPTION_POLICY 2148296211
     * }
     */
    public static long FS_IOC_SET_ENCRYPTION_POLICY() {
        return FS_IOC_SET_ENCRYPTION_POLICY;
    }
    private static final long FS_IOC_GET_ENCRYPTION_PWSALT = 1074816532L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GET_ENCRYPTION_PWSALT 1074816532
     * }
     */
    public static long FS_IOC_GET_ENCRYPTION_PWSALT() {
        return FS_IOC_GET_ENCRYPTION_PWSALT;
    }
    private static final long FS_IOC_GET_ENCRYPTION_POLICY = 1074554389L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GET_ENCRYPTION_POLICY 1074554389
     * }
     */
    public static long FS_IOC_GET_ENCRYPTION_POLICY() {
        return FS_IOC_GET_ENCRYPTION_POLICY;
    }
    private static final long FS_IOC_GET_ENCRYPTION_POLICY_EX = 3221841430L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GET_ENCRYPTION_POLICY_EX 3221841430
     * }
     */
    public static long FS_IOC_GET_ENCRYPTION_POLICY_EX() {
        return FS_IOC_GET_ENCRYPTION_POLICY_EX;
    }
    private static final long FS_IOC_ADD_ENCRYPTION_KEY = 3226494487L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_ADD_ENCRYPTION_KEY 3226494487
     * }
     */
    public static long FS_IOC_ADD_ENCRYPTION_KEY() {
        return FS_IOC_ADD_ENCRYPTION_KEY;
    }
    private static final long FS_IOC_REMOVE_ENCRYPTION_KEY = 3225445912L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_REMOVE_ENCRYPTION_KEY 3225445912
     * }
     */
    public static long FS_IOC_REMOVE_ENCRYPTION_KEY() {
        return FS_IOC_REMOVE_ENCRYPTION_KEY;
    }
    private static final long FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS = 3225445913L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS 3225445913
     * }
     */
    public static long FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS() {
        return FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS;
    }
    private static final long FS_IOC_GET_ENCRYPTION_KEY_STATUS = 3229640218L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GET_ENCRYPTION_KEY_STATUS 3229640218
     * }
     */
    public static long FS_IOC_GET_ENCRYPTION_KEY_STATUS() {
        return FS_IOC_GET_ENCRYPTION_KEY_STATUS;
    }
    private static final long FS_IOC_GET_ENCRYPTION_NONCE = 2148558363L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GET_ENCRYPTION_NONCE 2148558363
     * }
     */
    public static long FS_IOC_GET_ENCRYPTION_NONCE() {
        return FS_IOC_GET_ENCRYPTION_NONCE;
    }
    private static final int FS_KEY_DESCRIPTOR_SIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FS_KEY_DESCRIPTOR_SIZE 8
     * }
     */
    public static int FS_KEY_DESCRIPTOR_SIZE() {
        return FS_KEY_DESCRIPTOR_SIZE;
    }
    private static final int FS_POLICY_FLAGS_PAD_4 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAGS_PAD_4 0
     * }
     */
    public static int FS_POLICY_FLAGS_PAD_4() {
        return FS_POLICY_FLAGS_PAD_4;
    }
    private static final int FS_POLICY_FLAGS_PAD_8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAGS_PAD_8 1
     * }
     */
    public static int FS_POLICY_FLAGS_PAD_8() {
        return FS_POLICY_FLAGS_PAD_8;
    }
    private static final int FS_POLICY_FLAGS_PAD_16 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAGS_PAD_16 2
     * }
     */
    public static int FS_POLICY_FLAGS_PAD_16() {
        return FS_POLICY_FLAGS_PAD_16;
    }
    private static final int FS_POLICY_FLAGS_PAD_32 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAGS_PAD_32 3
     * }
     */
    public static int FS_POLICY_FLAGS_PAD_32() {
        return FS_POLICY_FLAGS_PAD_32;
    }
    private static final int FS_POLICY_FLAGS_PAD_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAGS_PAD_MASK 3
     * }
     */
    public static int FS_POLICY_FLAGS_PAD_MASK() {
        return FS_POLICY_FLAGS_PAD_MASK;
    }
    private static final int FS_POLICY_FLAG_DIRECT_KEY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FS_POLICY_FLAG_DIRECT_KEY 4
     * }
     */
    public static int FS_POLICY_FLAG_DIRECT_KEY() {
        return FS_POLICY_FLAG_DIRECT_KEY;
    }
    private static final int FS_ENCRYPTION_MODE_AES_256_XTS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FS_ENCRYPTION_MODE_AES_256_XTS 1
     * }
     */
    public static int FS_ENCRYPTION_MODE_AES_256_XTS() {
        return FS_ENCRYPTION_MODE_AES_256_XTS;
    }
    private static final int FS_ENCRYPTION_MODE_AES_256_CTS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FS_ENCRYPTION_MODE_AES_256_CTS 4
     * }
     */
    public static int FS_ENCRYPTION_MODE_AES_256_CTS() {
        return FS_ENCRYPTION_MODE_AES_256_CTS;
    }
    private static final int FS_ENCRYPTION_MODE_AES_128_CBC = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FS_ENCRYPTION_MODE_AES_128_CBC 5
     * }
     */
    public static int FS_ENCRYPTION_MODE_AES_128_CBC() {
        return FS_ENCRYPTION_MODE_AES_128_CBC;
    }
    private static final int FS_ENCRYPTION_MODE_AES_128_CTS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FS_ENCRYPTION_MODE_AES_128_CTS 6
     * }
     */
    public static int FS_ENCRYPTION_MODE_AES_128_CTS() {
        return FS_ENCRYPTION_MODE_AES_128_CTS;
    }
    private static final int FS_ENCRYPTION_MODE_ADIANTUM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FS_ENCRYPTION_MODE_ADIANTUM 9
     * }
     */
    public static int FS_ENCRYPTION_MODE_ADIANTUM() {
        return FS_ENCRYPTION_MODE_ADIANTUM;
    }
    /**
     * {@snippet lang=c :
     * #define FS_KEY_DESC_PREFIX "fscrypt:"
     * }
     */
    public static MemorySegment FS_KEY_DESC_PREFIX() {
        class Holder {
            static final MemorySegment FS_KEY_DESC_PREFIX
                = liburingtest.LIBRARY_ARENA.allocateFrom("fscrypt:");
        }
        return Holder.FS_KEY_DESC_PREFIX;
    }
    private static final int FS_KEY_DESC_PREFIX_SIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FS_KEY_DESC_PREFIX_SIZE 8
     * }
     */
    public static int FS_KEY_DESC_PREFIX_SIZE() {
        return FS_KEY_DESC_PREFIX_SIZE;
    }
    private static final int FS_MAX_KEY_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FS_MAX_KEY_SIZE 64
     * }
     */
    public static int FS_MAX_KEY_SIZE() {
        return FS_MAX_KEY_SIZE;
    }
    private static final int MS_POSIXACL = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MS_POSIXACL 65536
     * }
     */
    public static int MS_POSIXACL() {
        return MS_POSIXACL;
    }
    private static final int MS_UNBINDABLE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define MS_UNBINDABLE 131072
     * }
     */
    public static int MS_UNBINDABLE() {
        return MS_UNBINDABLE;
    }
    private static final int MS_PRIVATE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MS_PRIVATE 262144
     * }
     */
    public static int MS_PRIVATE() {
        return MS_PRIVATE;
    }
    private static final int MS_SLAVE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MS_SLAVE 524288
     * }
     */
    public static int MS_SLAVE() {
        return MS_SLAVE;
    }
    private static final int MS_SHARED = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define MS_SHARED 1048576
     * }
     */
    public static int MS_SHARED() {
        return MS_SHARED;
    }
    private static final int MS_RELATIME = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MS_RELATIME 2097152
     * }
     */
    public static int MS_RELATIME() {
        return MS_RELATIME;
    }
    private static final int MS_KERNMOUNT = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define MS_KERNMOUNT 4194304
     * }
     */
    public static int MS_KERNMOUNT() {
        return MS_KERNMOUNT;
    }
    private static final int MS_I_VERSION = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define MS_I_VERSION 8388608
     * }
     */
    public static int MS_I_VERSION() {
        return MS_I_VERSION;
    }
    private static final int MS_STRICTATIME = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define MS_STRICTATIME 16777216
     * }
     */
    public static int MS_STRICTATIME() {
        return MS_STRICTATIME;
    }
    private static final int MS_LAZYTIME = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define MS_LAZYTIME 33554432
     * }
     */
    public static int MS_LAZYTIME() {
        return MS_LAZYTIME;
    }
    private static final int MS_SUBMOUNT = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define MS_SUBMOUNT 67108864
     * }
     */
    public static int MS_SUBMOUNT() {
        return MS_SUBMOUNT;
    }
    private static final int MS_NOREMOTELOCK = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define MS_NOREMOTELOCK 134217728
     * }
     */
    public static int MS_NOREMOTELOCK() {
        return MS_NOREMOTELOCK;
    }
    private static final int MS_NOSEC = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define MS_NOSEC 268435456
     * }
     */
    public static int MS_NOSEC() {
        return MS_NOSEC;
    }
    private static final int MS_BORN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MS_BORN 536870912
     * }
     */
    public static int MS_BORN() {
        return MS_BORN;
    }
    private static final int MS_ACTIVE = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define MS_ACTIVE 1073741824
     * }
     */
    public static int MS_ACTIVE() {
        return MS_ACTIVE;
    }
    private static final int MS_NOUSER = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MS_NOUSER -2147483648
     * }
     */
    public static int MS_NOUSER() {
        return MS_NOUSER;
    }
    private static final int MS_RMT_MASK = (int)41943121L;
    /**
     * {@snippet lang=c :
     * #define MS_RMT_MASK 41943121
     * }
     */
    public static int MS_RMT_MASK() {
        return MS_RMT_MASK;
    }
    private static final int MS_MGC_VAL = (int)3236757504L;
    /**
     * {@snippet lang=c :
     * #define MS_MGC_VAL 3236757504
     * }
     */
    public static int MS_MGC_VAL() {
        return MS_MGC_VAL;
    }
    private static final int MS_MGC_MSK = (int)4294901760L;
    /**
     * {@snippet lang=c :
     * #define MS_MGC_MSK 4294901760
     * }
     */
    public static int MS_MGC_MSK() {
        return MS_MGC_MSK;
    }
    private static final int OPEN_TREE_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define OPEN_TREE_CLOEXEC 524288
     * }
     */
    public static int OPEN_TREE_CLOEXEC() {
        return OPEN_TREE_CLOEXEC;
    }
    private static final int STATMOUNT_SB_BASIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_SB_BASIC 1
     * }
     */
    public static int STATMOUNT_SB_BASIC() {
        return STATMOUNT_SB_BASIC;
    }
    private static final int STATMOUNT_MNT_BASIC = (int)2L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_MNT_BASIC 2
     * }
     */
    public static int STATMOUNT_MNT_BASIC() {
        return STATMOUNT_MNT_BASIC;
    }
    private static final int STATMOUNT_PROPAGATE_FROM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_PROPAGATE_FROM 4
     * }
     */
    public static int STATMOUNT_PROPAGATE_FROM() {
        return STATMOUNT_PROPAGATE_FROM;
    }
    private static final int STATMOUNT_MNT_ROOT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_MNT_ROOT 8
     * }
     */
    public static int STATMOUNT_MNT_ROOT() {
        return STATMOUNT_MNT_ROOT;
    }
    private static final int STATMOUNT_MNT_POINT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_MNT_POINT 16
     * }
     */
    public static int STATMOUNT_MNT_POINT() {
        return STATMOUNT_MNT_POINT;
    }
    private static final int STATMOUNT_FS_TYPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define STATMOUNT_FS_TYPE 32
     * }
     */
    public static int STATMOUNT_FS_TYPE() {
        return STATMOUNT_FS_TYPE;
    }
    private static final long LSMT_ROOT = -1L;
    /**
     * {@snippet lang=c :
     * #define LSMT_ROOT -1
     * }
     */
    public static long LSMT_ROOT() {
        return LSMT_ROOT;
    }
    private static final int BLOCK_SIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define BLOCK_SIZE 1024
     * }
     */
    public static int BLOCK_SIZE() {
        return BLOCK_SIZE;
    }
    private static final int SEEK_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SEEK_MAX 4
     * }
     */
    public static int SEEK_MAX() {
        return SEEK_MAX;
    }
    private static final int RENAME_NOREPLACE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RENAME_NOREPLACE 1
     * }
     */
    public static int RENAME_NOREPLACE() {
        return RENAME_NOREPLACE;
    }
    private static final int RENAME_EXCHANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RENAME_EXCHANGE 2
     * }
     */
    public static int RENAME_EXCHANGE() {
        return RENAME_EXCHANGE;
    }
    private static final int RENAME_WHITEOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RENAME_WHITEOUT 4
     * }
     */
    public static int RENAME_WHITEOUT() {
        return RENAME_WHITEOUT;
    }
    private static final int FS_XFLAG_HASATTR = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define FS_XFLAG_HASATTR 2147483648
     * }
     */
    public static int FS_XFLAG_HASATTR() {
        return FS_XFLAG_HASATTR;
    }
    private static final int BLKROSET = (int)4701L;
    /**
     * {@snippet lang=c :
     * #define BLKROSET 4701
     * }
     */
    public static int BLKROSET() {
        return BLKROSET;
    }
    private static final int BLKROGET = (int)4702L;
    /**
     * {@snippet lang=c :
     * #define BLKROGET 4702
     * }
     */
    public static int BLKROGET() {
        return BLKROGET;
    }
    private static final int BLKRRPART = (int)4703L;
    /**
     * {@snippet lang=c :
     * #define BLKRRPART 4703
     * }
     */
    public static int BLKRRPART() {
        return BLKRRPART;
    }
    private static final int BLKGETSIZE = (int)4704L;
    /**
     * {@snippet lang=c :
     * #define BLKGETSIZE 4704
     * }
     */
    public static int BLKGETSIZE() {
        return BLKGETSIZE;
    }
    private static final int BLKFLSBUF = (int)4705L;
    /**
     * {@snippet lang=c :
     * #define BLKFLSBUF 4705
     * }
     */
    public static int BLKFLSBUF() {
        return BLKFLSBUF;
    }
    private static final int BLKRASET = (int)4706L;
    /**
     * {@snippet lang=c :
     * #define BLKRASET 4706
     * }
     */
    public static int BLKRASET() {
        return BLKRASET;
    }
    private static final int BLKRAGET = (int)4707L;
    /**
     * {@snippet lang=c :
     * #define BLKRAGET 4707
     * }
     */
    public static int BLKRAGET() {
        return BLKRAGET;
    }
    private static final int BLKFRASET = (int)4708L;
    /**
     * {@snippet lang=c :
     * #define BLKFRASET 4708
     * }
     */
    public static int BLKFRASET() {
        return BLKFRASET;
    }
    private static final int BLKFRAGET = (int)4709L;
    /**
     * {@snippet lang=c :
     * #define BLKFRAGET 4709
     * }
     */
    public static int BLKFRAGET() {
        return BLKFRAGET;
    }
    private static final int BLKSECTSET = (int)4710L;
    /**
     * {@snippet lang=c :
     * #define BLKSECTSET 4710
     * }
     */
    public static int BLKSECTSET() {
        return BLKSECTSET;
    }
    private static final int BLKSECTGET = (int)4711L;
    /**
     * {@snippet lang=c :
     * #define BLKSECTGET 4711
     * }
     */
    public static int BLKSECTGET() {
        return BLKSECTGET;
    }
    private static final int BLKSSZGET = (int)4712L;
    /**
     * {@snippet lang=c :
     * #define BLKSSZGET 4712
     * }
     */
    public static int BLKSSZGET() {
        return BLKSSZGET;
    }
    private static final long BLKBSZGET = 2148012656L;
    /**
     * {@snippet lang=c :
     * #define BLKBSZGET 2148012656
     * }
     */
    public static long BLKBSZGET() {
        return BLKBSZGET;
    }
    private static final long BLKBSZSET = 1074270833L;
    /**
     * {@snippet lang=c :
     * #define BLKBSZSET 1074270833
     * }
     */
    public static long BLKBSZSET() {
        return BLKBSZSET;
    }
    private static final long BLKGETSIZE64 = 2148012658L;
    /**
     * {@snippet lang=c :
     * #define BLKGETSIZE64 2148012658
     * }
     */
    public static long BLKGETSIZE64() {
        return BLKGETSIZE64;
    }
    private static final int BLKTRACESTART = (int)4724L;
    /**
     * {@snippet lang=c :
     * #define BLKTRACESTART 4724
     * }
     */
    public static int BLKTRACESTART() {
        return BLKTRACESTART;
    }
    private static final int BLKTRACESTOP = (int)4725L;
    /**
     * {@snippet lang=c :
     * #define BLKTRACESTOP 4725
     * }
     */
    public static int BLKTRACESTOP() {
        return BLKTRACESTOP;
    }
    private static final int BLKTRACETEARDOWN = (int)4726L;
    /**
     * {@snippet lang=c :
     * #define BLKTRACETEARDOWN 4726
     * }
     */
    public static int BLKTRACETEARDOWN() {
        return BLKTRACETEARDOWN;
    }
    private static final int BLKDISCARD = (int)4727L;
    /**
     * {@snippet lang=c :
     * #define BLKDISCARD 4727
     * }
     */
    public static int BLKDISCARD() {
        return BLKDISCARD;
    }
    private static final int BLKIOMIN = (int)4728L;
    /**
     * {@snippet lang=c :
     * #define BLKIOMIN 4728
     * }
     */
    public static int BLKIOMIN() {
        return BLKIOMIN;
    }
    private static final int BLKIOOPT = (int)4729L;
    /**
     * {@snippet lang=c :
     * #define BLKIOOPT 4729
     * }
     */
    public static int BLKIOOPT() {
        return BLKIOOPT;
    }
    private static final int BLKALIGNOFF = (int)4730L;
    /**
     * {@snippet lang=c :
     * #define BLKALIGNOFF 4730
     * }
     */
    public static int BLKALIGNOFF() {
        return BLKALIGNOFF;
    }
    private static final int BLKPBSZGET = (int)4731L;
    /**
     * {@snippet lang=c :
     * #define BLKPBSZGET 4731
     * }
     */
    public static int BLKPBSZGET() {
        return BLKPBSZGET;
    }
    private static final int BLKDISCARDZEROES = (int)4732L;
    /**
     * {@snippet lang=c :
     * #define BLKDISCARDZEROES 4732
     * }
     */
    public static int BLKDISCARDZEROES() {
        return BLKDISCARDZEROES;
    }
    private static final int BLKSECDISCARD = (int)4733L;
    /**
     * {@snippet lang=c :
     * #define BLKSECDISCARD 4733
     * }
     */
    public static int BLKSECDISCARD() {
        return BLKSECDISCARD;
    }
    private static final int BLKROTATIONAL = (int)4734L;
    /**
     * {@snippet lang=c :
     * #define BLKROTATIONAL 4734
     * }
     */
    public static int BLKROTATIONAL() {
        return BLKROTATIONAL;
    }
    private static final int BLKZEROOUT = (int)4735L;
    /**
     * {@snippet lang=c :
     * #define BLKZEROOUT 4735
     * }
     */
    public static int BLKZEROOUT() {
        return BLKZEROOUT;
    }
    private static final long BLKGETDISKSEQ = 2148012672L;
    /**
     * {@snippet lang=c :
     * #define BLKGETDISKSEQ 2148012672
     * }
     */
    public static long BLKGETDISKSEQ() {
        return BLKGETDISKSEQ;
    }
    private static final int FIBMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FIBMAP 1
     * }
     */
    public static int FIBMAP() {
        return FIBMAP;
    }
    private static final int FIGETBSZ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FIGETBSZ 2
     * }
     */
    public static int FIGETBSZ() {
        return FIGETBSZ;
    }
    private static final long FIFREEZE = 3221510263L;
    /**
     * {@snippet lang=c :
     * #define FIFREEZE 3221510263
     * }
     */
    public static long FIFREEZE() {
        return FIFREEZE;
    }
    private static final long FITHAW = 3221510264L;
    /**
     * {@snippet lang=c :
     * #define FITHAW 3221510264
     * }
     */
    public static long FITHAW() {
        return FITHAW;
    }
    private static final long FITRIM = 3222820985L;
    /**
     * {@snippet lang=c :
     * #define FITRIM 3222820985
     * }
     */
    public static long FITRIM() {
        return FITRIM;
    }
    private static final long FICLONE = 1074041865L;
    /**
     * {@snippet lang=c :
     * #define FICLONE 1074041865
     * }
     */
    public static long FICLONE() {
        return FICLONE;
    }
    private static final long FICLONERANGE = 1075876877L;
    /**
     * {@snippet lang=c :
     * #define FICLONERANGE 1075876877
     * }
     */
    public static long FICLONERANGE() {
        return FICLONERANGE;
    }
    private static final long FIDEDUPERANGE = 3222836278L;
    /**
     * {@snippet lang=c :
     * #define FIDEDUPERANGE 3222836278
     * }
     */
    public static long FIDEDUPERANGE() {
        return FIDEDUPERANGE;
    }
    private static final long FS_IOC_GETFLAGS = 2148034049L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GETFLAGS 2148034049
     * }
     */
    public static long FS_IOC_GETFLAGS() {
        return FS_IOC_GETFLAGS;
    }
    private static final long FS_IOC_SETFLAGS = 1074292226L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_SETFLAGS 1074292226
     * }
     */
    public static long FS_IOC_SETFLAGS() {
        return FS_IOC_SETFLAGS;
    }
    private static final long FS_IOC_GETVERSION = 2148038145L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_GETVERSION 2148038145
     * }
     */
    public static long FS_IOC_GETVERSION() {
        return FS_IOC_GETVERSION;
    }
    private static final long FS_IOC_SETVERSION = 1074296322L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC_SETVERSION 1074296322
     * }
     */
    public static long FS_IOC_SETVERSION() {
        return FS_IOC_SETVERSION;
    }
    private static final long FS_IOC32_GETFLAGS = 2147771905L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC32_GETFLAGS 2147771905
     * }
     */
    public static long FS_IOC32_GETFLAGS() {
        return FS_IOC32_GETFLAGS;
    }
    private static final long FS_IOC32_SETFLAGS = 1074030082L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC32_SETFLAGS 1074030082
     * }
     */
    public static long FS_IOC32_SETFLAGS() {
        return FS_IOC32_SETFLAGS;
    }
    private static final long FS_IOC32_GETVERSION = 2147776001L;
    /**
     * {@snippet lang=c :
     * #define FS_IOC32_GETVERSION 2147776001
     * }
     */
    public static long FS_IOC32_GETVERSION() {
        return FS_IOC32_GETVERSION;
    }
}

